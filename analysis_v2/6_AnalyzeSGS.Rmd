---
title: "Untitled"
author: "Your Name Here"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse); theme_set(theme_bw())
library(ggpattern)
library(lme4)
library(broom.mixed)
library(Matrix)
library(MuMIn)
library(colorspace)
library(ade4)
```

## Load and process data
```{r, eval=FALSE}
########## Process empirical FSTs (only need to do this once)

fst_emp <- read.csv('../data/FST_empirical.csv',header=T)
fst_emp_long <- pivot_longer(fst_emp,cols=2:ncol(fst_emp),names_to=c('site2'))
fst_emp_long$sites <- NA
for(i in 1:nrow(fst_emp_long)){
  fst_emp_long$sites[i] <- paste(sort(as.matrix(fst_emp_long[i,1:2])),collapse='.')
}
fst_emp_long <- filter(fst_emp_long,!is.na(value)) %>%
  rename(emp_fst=value)
fst_emp <- dplyr::select(fst_emp_long,sites,fst=emp_fst) 
rm(fst_emp_long)

save(fst_emp, file='../data/FST_emp.RData')

```

```{r, eval=FALSE}
########## Process data into a format to use in the analyses in this file
n_run=3

## load data
load(file='../data/FST_emp.RData') # empirical FSTs
sample_sites <- read_csv('../data/sgs_sites_SLiM.csv',show_col_types=FALSE) #info on sample sites
fst_folder_path <- paste0('../data/full_pop_run/A',n_run)
load(file=paste0(fst_folder_path,"/FST_all.RData")) #sequence of simulated FST data

## strip site1 and site2, and re-add them, so they're in the right order (match the order in sites)
fst_all_sim <- dplyr::select(fst_all_sim, sites,tick,fst) %>%
  separate_wider_delim(sites,delim=".",names=c("site1","site2"),cols_remove=FALSE)

## add region1 and region2 columns
regions <- unique(sample_sites$Region)
N_list <- filter(sample_sites,Region==regions[1])$Site
C_list <- filter(sample_sites,Region==regions[2])$Site
T_list <- filter(sample_sites,Region==regions[3])$Site
G_list <- filter(sample_sites,Region==regions[4])$Site
L_list <- filter(sample_sites,Region==regions[5])$Site
S_list <- filter(sample_sites,Region==regions[6])$Site

fst_all_sim <- fst_all_sim %>%
  mutate(region1=case_match(site1, N_list~'N',C_list~'C',T_list~'T',G_list~'G',L_list~'L',S_list~'S'),
         region2=case_match(site2, N_list~'N',C_list~'C',T_list~'T',G_list~'G',L_list~'L',S_list~'S'))

## add both_regions column (in alphabetical order, so we don't have e.g. BG and GB)
fst_all_sim$both_regions <- NA
for(j in 1:nrow(fst_all_sim)){
  fst_all_sim$both_regions[j] <- paste0(sort(as.matrix(fst_all_sim[j,c('region1','region2')])), collapse='')
}

fst_all_sim <- left_join(fst_all_sim,fst_emp,by='sites') %>%
  rename(fst_sim=fst.x, fst_emp=fst.y) %>%
  filter(!is.na(fst_emp))%>%
  dplyr::select(tick,sites,site1,site2,region1,region2,both_regions,fst_sim,fst_emp)


## make a new dataframe that summarizes across ticks
fst_summary <- filter(fst_all_sim, tick>2500) %>% # remove the pre-equilibrium values! Important!
  group_by(sites) %>%
  summarize(median=median(fst_sim), mean=mean(fst_sim), sd = sd(fst_sim), q95_low=quantile(fst_sim,0.025),
            q95_up=quantile(fst_sim,0.975),both_regions=first(both_regions)) %>%
  left_join(fst_emp,by='sites') %>%
  rename(fst_emp=fst) %>%
  filter(!is.na(fst_emp))

#save(fst_all_sim,fst_summary,file=paste0("../data/full_pop_run/fst_data_for_analysis_A",n_run,".RData"))
```

```{r}
n_run=1
load(paste0("../data/full_pop_run/fst_data_for_analysis_A",n_run,".RData"))
load(file='../data/FST_emp.RData') # empirical FSTs
```


## Dynamics

```{r}
all_by_tick <- group_by(fst_all_sim,tick) %>% summarize(mean_fst=mean(fst_sim))

fst_all_sim <- fst_all_sim %>%
  mutate(both_pops=case_match(both_regions,
                              c('NN','CC','TT','CN','CT','NT')~'BB', 
                              c('CG','GN','GT')~'BG',
                              c('CL','LN','LT')~'BL',
                              .default=both_regions))

group_by(fst_all_sim,tick,both_pops) %>%
  summarize(pop_fst=mean(fst_sim)) %>%
  ggplot(aes(x=tick,y=pop_fst,color=both_pops))+
  geom_line()+
  geom_line(data=all_by_tick,aes(x=tick,y=mean_fst),color='black')

group_by(fst_all_sim,tick,both_regions) %>%
  summarize(pop_fst=mean(fst_sim)) %>%
  filter(tick>2500) %>%
  ggplot(aes(x=tick,y=pop_fst,color=both_regions))+
  geom_line()+
  geom_hline(aes(yintercept=0))+
  facet_wrap(vars(both_regions), scales="free")#+
  geom_smooth(method='lm',se=FALSE)
  
ggplot(data=all_by_tick,aes(x=tick,y=mean_fst))+
  geom_line()+
  geom_point()

```

### Autocorrelation

```{r}
# first do it all together, then we'll break it up by region pair
fst_autocorr <- fst_all_sim %>%
  filter(tick>2500) %>%
  group_by(tick) %>%
  summarize(mean_fst = mean(fst_sim))

a <- acf(fst_autocorr$mean_fst,20)
#p <- pacf(fst_autocorr$mean_fst,20)

# significant autocorrelation up to lag of 3, i.e., 3*200=600 ticks

fst_autocorr <- fst_all_sim %>%
  filter(tick>2500) %>%
  group_by(tick, both_regions) %>%
  summarize(mean_fst = mean(fst_sim))

regionpairs <- unique(fst_autocorr$both_regions)
autocorrs <- data.frame(lag=numeric(), aut=numeric(),paut=numeric(), regionpair=factor())
for(regpair in regionpairs){
  temp_df <- data.frame(lag=0:20, 
                        aut=acf(filter(fst_autocorr, both_regions==regpair)$mean_fst,20, plot=FALSE)$acf, 
                        paut=c(NA,pacf(filter(fst_autocorr, both_regions==regpair)$mean_fst,20, plot=FALSE)$acf), 
                        regionpair=rep(regpair,21))
  autocorrs <- rbind(autocorrs,temp_df)
}

ggplot(data=autocorrs,aes(x=lag))+
  geom_segment(aes(xend=lag,y=0,yend=aut))+
  geom_hline(aes(yintercept=c(-2/sqrt(length(unique(fst_autocorr$tick))))), color='red')+
  geom_hline(aes(yintercept=c(2/sqrt(length(unique(fst_autocorr$tick))))),color='red')+
  facet_wrap(vars(regionpair))

# ggplot(data=autocorrs,aes(x=lag))+
#   geom_segment(aes(xend=lag,y=0,yend=paut))+
#   geom_hline(aes(yintercept=c(-2/sqrt(length(unique(fst_autocorr$tick))))), color='red')+
#   geom_hline(aes(yintercept=c(2/sqrt(length(unique(fst_autocorr$tick))))),color='red')+
#   facet_wrap(vars(regionpair))
```

## Predicted vs observed FST plots

```{r}
fst_summary <- fst_summary %>%
  mutate(regions_grp=factor(case_match(both_regions, 
                                c('CG','GN','GT','CL','LN','LT','GL')~1, c('CN','CT','NT')~2, c('NN','CC','TT','GG','LL')~3)))
```


```{r}
# overview: all points
colors_all=c('1'="#66CCEE",'2'="#CCBB44",'3'="#AA3377")
ggplot(fst_summary,aes(y=fst_emp,x=mean))+
  geom_errorbar(aes(xmin=mean-sd,xmax=mean+sd, color=regions_grp),position = position_jitter(seed = 100), alpha=0.15)+
  geom_point(aes(color=regions_grp), position = position_jitter(seed = 100))+
  geom_abline(aes(slope=1,intercept=0))+
  theme_bw()+
  scale_color_manual(values=colors_all)+
  #labs(y = "empirical FST", x="simulated FST (mean+/-sd over 7500 generations)")+
  coord_fixed()+
  theme(legend.position="none",axis.title.x=element_blank(),axis.title.y=element_blank())

# group 1: N/C/T <--> G <--> L
shapes_1=c('GL'=8,'CG'=0,'GN'=1,'GT'=2,'CL'=15,'LN'=16,'LT'=17)
fst_summary %>%
  filter(regions_grp==1) %>%
  mutate(both_regions=factor(both_regions,levels=c('CL','LN','LT','CG','GN','GT','GL'))) %>%
  ggplot(aes(y=fst_emp,x=mean))+
    geom_errorbar(aes(xmin=mean-sd,xmax=mean+sd),color=colors_all[1],position = position_jitter(seed = 100), alpha=0.15)+
    geom_point(aes(shape=both_regions),color=colors_all[1],fill=colors_all[1],position = position_jitter(seed = 100))+
    geom_abline(aes(slope=1,intercept=0))+
    theme_bw()+
    #theme(panel.border=element_rect(colour=colors_all[1], fill=NA, linewidth=2))+
    theme(legend.position = c(0.89,0.76),legend.background=element_rect(fill='white',size=0.5),legend.title=element_blank())+
    theme(legend.title=element_blank(),axis.title.x=element_blank(),axis.title.y=element_blank())+
    scale_shape_manual(values=shapes_1)+
    #labs(y = "empirical FST", x="simulated FST (mean+/-sd over 7500 generations)")+
    #guides(shape=guide_legend(ncol=3, byrow=TRUE))+
    coord_fixed()

# group 2: N <--> C <--> T
shapes_2=c('CN'=8,'NT'=1,'CT'=16)
fst_summary %>%
  filter(regions_grp==2) %>%
  mutate(both_regions=factor(both_regions,levels=c('CN','NT','CT'))) %>%
  ggplot(aes(y=fst_emp,x=mean))+
    geom_errorbar(aes(xmin=mean-sd,xmax=mean+sd),color=colors_all[2],position = position_jitter(seed = 100), alpha=0.15)+
    geom_point(aes(shape=both_regions),color=colors_all[2],fill=colors_all[2],position = position_jitter(seed = 100))+
    geom_abline(aes(slope=1,intercept=0))+
    theme_bw()+
    #theme(panel.border=element_rect(colour=colors_all[2], fill=NA, linewidth=2))+
    theme(legend.position = c(0.89,0.72),legend.background=element_rect(fill='white',size=0.5),legend.title=element_blank())+
    theme(legend.title=element_blank(),axis.title.x=element_blank(),axis.title.y=element_blank())+
    scale_shape_manual(values=shapes_2)+
    #labs(y = "empirical FST", x="simulated FST (mean+/-sd over 7500 generations)")+
    #guides(shape=guide_legend(ncol=3, byrow=TRUE))+
    coord_fixed()

# group 3: withins
shapes_3=c('CC'=0,'NN'=2,'TT'=8,'GG'=16,'LL'=17)
fst_summary %>%
  filter(regions_grp==3) %>%
  mutate(both_regions=factor(both_regions,levels=c('NN','CC','TT','LL','GG'))) %>%
  ggplot(aes(y=fst_emp,x=mean))+
    geom_errorbar(aes(xmin=mean-sd,xmax=mean+sd),color=colors_all[3],position = position_jitter(seed = 100), alpha=0.15)+
    geom_point(aes(shape=both_regions),color=colors_all[3],fill=colors_all[3],position = position_jitter(seed = 100))+
    geom_abline(aes(slope=1,intercept=0))+
    theme_bw()+
    #theme(panel.border=element_rect(colour=colors_all[3], fill=NA, linewidth=2))+
    theme(legend.position = c(0.89,0.68),legend.background=element_rect(fill='white',size=0.5),legend.title=element_blank())+
    theme(legend.title=element_blank(),axis.title.x=element_blank(),axis.title.y=element_blank())+
    scale_shape_manual(values=shapes_3)+
    #labs(y = "empirical FST", x="simulated FST (mean+/-sd over 7500 generations)")+
    #guides(shape=guide_legend(ncol=3, byrow=TRUE))+
    coord_fixed()

```


### Broad-scale
```{r}
ggplot(fst_summary,aes(x=fst_emp,y=mean))+
  geom_errorbar(aes(ymin=mean-sd,ymax=mean+sd, color=both_pops),position = position_jitter(seed = 100), alpha=0.15)+
  geom_point(aes(color=both_pops), position = position_jitter(seed = 100))+
  geom_abline(aes(slope=1,intercept=0))+
  theme_minimal()+
  xlim(c(-0.005, 0.032))+
  ylim(c(-0.005, 0.032))+
  labs(x = "empirical FST", y="simulated FST (mean+/-sd over 7500 generations)")+
  coord_flip()
```
### Fine-scale
```{r}
ggplot(filter(fst_summary,both_regions %in% c('NN','CC','TT','CN','NT','CT')),aes(x=fst_emp,y=mean))+
  geom_errorbar(aes(ymin=mean-sd,ymax=mean+sd, color=both_regions),position = position_jitter(seed = 100), alpha=0.15)+
  geom_point(aes(color=both_regions, shape=both_regions), position = position_jitter(seed = 100))+
  scale_color_discrete_qualitative(palette="Harmonic")+
  geom_abline(aes(slope=1,intercept=0))+
  theme_minimal()+
  labs(x = "empirical FST", y="simulated FST (mean+/-sd over 7500 generations)")+
  coord_flip()
```


## Linear model of observed vs predicted FSTs
To think about using the values over time, take a look at: https://bbolker.github.io/mixedmodels-misc/notes/corr_braindump.html

### Updated version.
#### Use the mean
Model selection:
```{r}
## prepare data
fst_data <- fst_summary %>%
  mutate(regions_grp=factor(case_match(both_regions, 
                                c('CG','GN','GT','CL','LN','LT','GL')~1, c('CN','CT','NT')~2, c('NN','CC','TT','GG','LL')~3))) %>%
  mutate(regions_grp_2=factor(case_match(regions_grp,'1'~'A',c('2','3')~'B'))) %>% #within-B and within-site grouped together in '2'
  mutate(regions_grp_3=factor(case_match(regions_grp,c('1','2')~'C','3'~'D'))) %>% #within-B and B-atolls grouped together in '1'
  mutate(site1=str_split_i(sites,"\\.",1)) %>%
  mutate(site2=str_split_i(sites,"\\.",2)) %>%
  rename(sim_fst_mean=mean)

## make model matrix W to account for nonindependence among site pairs
site_list <- unique(c(fst_data$site1,fst_data$site2))
W = matrix(nrow=nrow(fst_data),ncol=length(site_list))
colnames(W) = site_list
rownames(W) = fst_data$sites
for(i in 1:nrow(W)){
  for(j in 1:ncol(W)){
    W[i,j] = ifelse((site_list[j] == fst_data$site1[i]) | (site_list[j] == fst_data$site2[i]), 1, 0)
  } # j (sites)
} # i (site pairs) 
fst_data$sitenames <- rep(site_list,length.out=nrow(fst_data)) ## make a dummy column with the right item names

## make sure to use ML instead of REML, because we're doing an ANOVA and the fixed effects are different among models.
## model 1: no region pair group
lmod1 <- lFormula(fst_emp~sim_fst_mean+(1|sitenames), data=fst_data, REML=FALSE) ## create the model
lmod1$reTrms$Zt <- lmod1$reTrms$Ztlist[[1]] <- Matrix(t(W))  ## give the actual model matrix Zt to the model
devfun1 <- do.call(mkLmerDevfun, lmod1) ## makes a deviance function
opt1 <- optimizeLmer(devfun1) ## takes a deviance function and optimizes over theta
m1 <- mkMerMod(environment(devfun1), opt1, lmod1$reTrms, fr = lmod1$fr) ## produces a lmerMod object from previous steps

## model 2: region pair group included as a predictor: group A (B-atolls) and group B (within-B, within-region)
lmod2 <- lFormula(fst_emp~sim_fst_mean+regions_grp_2+sim_fst_mean*regions_grp_2+(1|sitenames), data=fst_data, REML=FALSE) ## create the model
lmod2$reTrms$Zt <- lmod2$reTrms$Ztlist[[1]] <- Matrix(t(W))  ## give the actual model matrix Zt to the model
devfun2 <- do.call(mkLmerDevfun, lmod2) ## makes a deviance function
opt2 <- optimizeLmer(devfun2) ## takes a deviance function and optimizes over theta
m2 <- mkMerMod(environment(devfun2), opt2, lmod2$reTrms, fr = lmod2$fr) ## produces a lmerMod object from previous steps

## model 3: region pair group included as a predictor: group C (B-atolls, within-B) and group D (within-region)
lmod3 <- lFormula(fst_emp~sim_fst_mean+regions_grp_3+sim_fst_mean*regions_grp_3+(1|sitenames), data=fst_data, REML=FALSE) ## create the model
lmod3$reTrms$Zt <- lmod3$reTrms$Ztlist[[1]] <- Matrix(t(W))  ## give the actual model matrix Zt to the model
devfun3 <- do.call(mkLmerDevfun, lmod3) ## makes a deviance function
opt3 <- optimizeLmer(devfun3) ## takes a deviance function and optimizes over theta
m3 <- mkMerMod(environment(devfun3), opt3, lmod3$reTrms, fr = lmod3$fr) ## produces a lmerMod object from previous steps

## model 4: region pair group included as a predictor
lmod4 <- lFormula(fst_emp~sim_fst_mean+regions_grp+sim_fst_mean*regions_grp+(1|sitenames), data=fst_data, REML=FALSE) ## create the model
lmod4$reTrms$Zt <- lmod4$reTrms$Ztlist[[1]] <- Matrix(t(W))  ## give the actual model matrix Zt to the model
devfun4 <- do.call(mkLmerDevfun, lmod4) ## makes a deviance function
opt4 <- optimizeLmer(devfun4) ## takes a deviance function and optimizes over theta
m4 <- mkMerMod(environment(devfun4), opt4, lmod4$reTrms, fr = lmod4$fr) ## produces a lmerMod object from previous steps

anova(m1,m2,m3,m4)
```
Slopes:
```{r}
coefs_meandata <- as.data.frame(summary(m4)$coefficients) %>% rownames_to_column()
CI_meandata <- as.data.frame(confint(m4)) %>% rownames_to_column()

coefs_meandata <- left_join(coefs_meandata,CI_meandata,by='rowname')
colnames(coefs_meandata) <- c('rowname','est','se','t','l95','u95')

fit_to_grp_meandata <- data.frame(grp=factor(c('1','2','3')), slope=NA, intercept=NA)
fit_to_grp_meandata$intercept=c(coefs_meandata$est[1],coefs_meandata$est[1]+coefs_meandata$est[3],coefs_meandata$est[1]+coefs_meandata$est[4])
fit_to_grp_meandata$slope=c(coefs_meandata$est[2],coefs_meandata$est[2]+coefs_meandata$est[5],coefs_meandata$est[2]+coefs_meandata$est[6])
```
```{r}
## Now make a plot with the fitted lines on it:
fst_summary <- fst_summary %>%
  mutate(regions_grp=factor(case_match(both_regions, 
                                c('CG','GN','GT','CL','LN','LT','GL')~1, c('CN','CT','NT')~2, c('NN','CC','TT','GG','LL')~3)))

# overview: all points
colors_all=c('1'="#66CCEE",'2'="#CCBB44",'3'="#AA3377")
ggplot(fst_summary,aes(y=fst_emp,x=mean))+
  geom_errorbar(aes(xmin=mean-sd,xmax=mean+sd, color=regions_grp),position = position_jitter(seed = 100), alpha=0.15)+
  geom_point(aes(color=regions_grp), position = position_jitter(seed = 100))+
  geom_abline(aes(slope=1,intercept=0))+
  theme_bw()+
  scale_color_manual(values=colors_all)+
  #labs(y = "empirical FST", x="simulated FST (mean+/-sd over 7500 generations)")+
  coord_fixed()+
  theme(legend.position="none",axis.title.x=element_blank(),axis.title.y=element_blank())

# group 1: N/C/T <--> G <--> L
shapes_1=c('GL'=8,'CG'=0,'GN'=1,'GT'=2,'CL'=15,'LN'=16,'LT'=17)
fst_summary %>%
  filter(regions_grp==1) %>%
  mutate(both_regions=factor(both_regions,levels=c('CL','LN','LT','CG','GN','GT','GL'))) %>%
  ggplot(aes(y=fst_emp,x=mean))+
    geom_errorbar(aes(xmin=mean-sd,xmax=mean+sd),color=colors_all[1],position = position_jitter(seed = 100), alpha=0.15)+
    geom_point(aes(shape=both_regions),color=colors_all[1],fill=colors_all[1],position = position_jitter(seed = 100))+
    geom_abline(aes(slope=1,intercept=0))+
    geom_abline(aes(slope=fit_to_grp_meandata$slope[1],intercept=fit_to_grp_meandata$intercept[1]),color=colors_all[1])+
    theme_bw()+
    #theme(panel.border=element_rect(colour=colors_all[1], fill=NA, linewidth=2))+
    theme(legend.position = c(0.89,0.76),legend.background=element_rect(fill='white',size=0.5),legend.title=element_blank())+
    theme(legend.title=element_blank(),axis.title.x=element_blank(),axis.title.y=element_blank())+
    scale_shape_manual(values=shapes_1)+
    #labs(y = "empirical FST", x="simulated FST (mean+/-sd over 7500 generations)")+
    #guides(shape=guide_legend(ncol=3, byrow=TRUE))+
    coord_fixed()

# group 2: N <--> C <--> T
shapes_2=c('CN'=8,'NT'=1,'CT'=16)
fst_summary %>%
  filter(regions_grp==2) %>%
  mutate(both_regions=factor(both_regions,levels=c('CN','NT','CT'))) %>%
  ggplot(aes(y=fst_emp,x=mean))+
    geom_errorbar(aes(xmin=mean-sd,xmax=mean+sd),color=colors_all[2],position = position_jitter(seed = 100), alpha=0.15)+
    geom_point(aes(shape=both_regions),color=colors_all[2],fill=colors_all[2],position = position_jitter(seed = 100))+
    geom_abline(aes(slope=1,intercept=0))+
      geom_abline(aes(slope=fit_to_grp_meandata$slope[2],intercept=fit_to_grp_meandata$intercept[2]),color=colors_all[2])+  
  theme_bw()+
    #theme(panel.border=element_rect(colour=colors_all[2], fill=NA, linewidth=2))+
    theme(legend.position = c(0.89,0.72),legend.background=element_rect(fill='white',size=0.5),legend.title=element_blank())+
    theme(legend.title=element_blank(),axis.title.x=element_blank(),axis.title.y=element_blank())+
    scale_shape_manual(values=shapes_2)+
    #labs(y = "empirical FST", x="simulated FST (mean+/-sd over 7500 generations)")+
    #guides(shape=guide_legend(ncol=3, byrow=TRUE))+
    coord_fixed()

# group 3: withins
shapes_3=c('CC'=0,'NN'=2,'TT'=8,'GG'=16,'LL'=17)
fst_summary %>%
  filter(regions_grp==3) %>%
  mutate(both_regions=factor(both_regions,levels=c('NN','CC','TT','LL','GG'))) %>%
  ggplot(aes(y=fst_emp,x=mean))+
    geom_errorbar(aes(xmin=mean-sd,xmax=mean+sd),color=colors_all[3],position = position_jitter(seed = 100), alpha=0.15)+
    geom_point(aes(shape=both_regions),color=colors_all[3],fill=colors_all[3],position = position_jitter(seed = 100))+
    geom_abline(aes(slope=1,intercept=0))+
      geom_abline(aes(slope=fit_to_grp_meandata$slope[3],intercept=fit_to_grp_meandata$intercept[3]),color=colors_all[3])+  
  theme_bw()+
    #theme(panel.border=element_rect(colour=colors_all[3], fill=NA, linewidth=2))+
    theme(legend.position = c(0.89,0.68),legend.background=element_rect(fill='white',size=0.5),legend.title=element_blank())+
    theme(legend.title=element_blank(),axis.title.x=element_blank(),axis.title.y=element_blank())+
    scale_shape_manual(values=shapes_3)+
    #labs(y = "empirical FST", x="simulated FST (mean+/-sd over 7500 generations)")+
    #guides(shape=guide_legend(ncol=3, byrow=TRUE))+
    coord_fixed()

```
#### Don't control for nonindependence among site pairs: (also using the mean)
```{r}
m5 <- lm(fst_emp~sim_fst_mean+regions_grp+sim_fst_mean*regions_grp, data=fst_data)
coefs_norand <- as.data.frame(summary(m5)$coefficients) %>%
  rename(est=Estimate)
fit_to_grp_norand <- data.frame(grp=factor(c('1','2','3')), slope=NA, intercept=NA)
fit_to_grp_norand$intercept=c(coefs_norand$est[1],coefs_norand$est[1]+coefs_norand$est[3],coefs_norand$est[1]+coefs_norand$est[4])
fit_to_grp_norand$slope=c(coefs_norand$est[2],coefs_norand$est[2]+coefs_norand$est[5],coefs_norand$est[2]+coefs_norand$est[6])


fst_summary <- fst_summary %>%
  mutate(regions_grp=factor(case_match(both_regions, 
                                c('CG','GN','GT','CL','LN','LT','GL')~1, c('CN','CT','NT')~2, c('NN','CC','TT','GG','LL')~3)))
colors_all=c('1'="#66CCEE",'2'="#CCBB44",'3'="#AA3377")
# group 1: N/C/T <--> G <--> L
shapes_1=c('GL'=8,'CG'=0,'GN'=1,'GT'=2,'CL'=15,'LN'=16,'LT'=17)
fst_summary %>%
  filter(regions_grp==1) %>%
  mutate(both_regions=factor(both_regions,levels=c('CL','LN','LT','CG','GN','GT','GL'))) %>%
  ggplot(aes(y=fst_emp,x=mean))+
    geom_errorbar(aes(xmin=mean-sd,xmax=mean+sd),color=colors_all[1],position = position_jitter(seed = 100), alpha=0.15)+
    geom_point(aes(shape=both_regions),color=colors_all[1],fill=colors_all[1],position = position_jitter(seed = 100))+
    geom_abline(aes(slope=1,intercept=0))+
    geom_abline(aes(slope=fit_to_grp_norand$slope[1],intercept=fit_to_grp_norand$intercept[1]),color=colors_all[1])+
    theme_bw()+
    #theme(panel.border=element_rect(colour=colors_all[1], fill=NA, linewidth=2))+
    theme(legend.position = c(0.89,0.76),legend.background=element_rect(fill='white',size=0.5),legend.title=element_blank())+
    theme(legend.title=element_blank(),axis.title.x=element_blank(),axis.title.y=element_blank())+
    scale_shape_manual(values=shapes_1)+
    #labs(y = "empirical FST", x="simulated FST (mean+/-sd over 7500 generations)")+
    #guides(shape=guide_legend(ncol=3, byrow=TRUE))+
    coord_fixed()

# group 2: N <--> C <--> T
shapes_2=c('CN'=8,'NT'=1,'CT'=16)
fst_summary %>%
  filter(regions_grp==2) %>%
  mutate(both_regions=factor(both_regions,levels=c('CN','NT','CT'))) %>%
  ggplot(aes(y=fst_emp,x=mean))+
    geom_errorbar(aes(xmin=mean-sd,xmax=mean+sd),color=colors_all[2],position = position_jitter(seed = 100), alpha=0.15)+
    geom_point(aes(shape=both_regions),color=colors_all[2],fill=colors_all[2],position = position_jitter(seed = 100))+
    geom_abline(aes(slope=1,intercept=0))+
      geom_abline(aes(slope=fit_to_grp_norand$slope[2],intercept=fit_to_grp_norand$intercept[2]),color=colors_all[2])+  
  theme_bw()+
    #theme(panel.border=element_rect(colour=colors_all[2], fill=NA, linewidth=2))+
    theme(legend.position = c(0.89,0.72),legend.background=element_rect(fill='white',size=0.5),legend.title=element_blank())+
    theme(legend.title=element_blank(),axis.title.x=element_blank(),axis.title.y=element_blank())+
    scale_shape_manual(values=shapes_2)+
    #labs(y = "empirical FST", x="simulated FST (mean+/-sd over 7500 generations)")+
    #guides(shape=guide_legend(ncol=3, byrow=TRUE))+
    coord_fixed()

# group 3: withins
shapes_3=c('CC'=0,'NN'=2,'TT'=8,'GG'=16,'LL'=17)
fst_summary %>%
  filter(regions_grp==3) %>%
  mutate(both_regions=factor(both_regions,levels=c('NN','CC','TT','LL','GG'))) %>%
  ggplot(aes(y=fst_emp,x=mean))+
    geom_errorbar(aes(xmin=mean-sd,xmax=mean+sd),color=colors_all[3],position = position_jitter(seed = 100), alpha=0.15)+
    geom_point(aes(shape=both_regions),color=colors_all[3],fill=colors_all[3],position = position_jitter(seed = 100))+
    geom_abline(aes(slope=1,intercept=0))+
      geom_abline(aes(slope=fit_to_grp_norand$slope[3],intercept=fit_to_grp_norand$intercept[3]),color=colors_all[3])+  
  theme_bw()+
    #theme(panel.border=element_rect(colour=colors_all[3], fill=NA, linewidth=2))+
    theme(legend.position = c(0.89,0.68),legend.background=element_rect(fill='white',size=0.5),legend.title=element_blank())+
    theme(legend.title=element_blank(),axis.title.x=element_blank(),axis.title.y=element_blank())+
    scale_shape_manual(values=shapes_3)+
    #labs(y = "empirical FST", x="simulated FST (mean+/-sd over 7500 generations)")+
    #guides(shape=guide_legend(ncol=3, byrow=TRUE))+
    coord_fixed()
```


#### Use all the data, not just the mean.
```{r}
## prepare data
fst_all_sim <- fst_all_sim %>%
  filter(tick>2500) %>%
  mutate(regions_grp=factor(case_match(both_regions, 
                                c('CG','GN','GT','CL','LN','LT','GL')~1, c('CN','CT','NT')~2, c('NN','CC','TT','GG','LL')~3))) %>%
  mutate(regions_grp_2=factor(case_match(regions_grp,'1'~'A',c('2','3')~'B'))) %>% #within-B and within-site grouped together in 'B'
  mutate(regions_grp_3=factor(case_match(regions_grp,c('1','2')~'C','3'~'D'))) #within-B and B-atolls grouped together in 'C'

## make model matrix W to account for nonindependence among site pairs
site_list <- unique(c(fst_all_sim$site1,fst_all_sim$site2))
W = matrix(nrow=nrow(fst_all_sim),ncol=length(site_list))
colnames(W) = site_list
rownames(W) = fst_all_sim$sites
for(i in 1:nrow(W)){
  for(j in 1:ncol(W)){
    W[i,j] = ifelse((site_list[j] == fst_all_sim$site1[i]) | (site_list[j] == fst_all_sim$site2[i]), 1, 0)
  } # j (sites)
} # i (site pairs)
fst_all_sim$sitenames <- rep(site_list,length.out=nrow(fst_all_sim)) ## make a dummy column with the right item names

## model 1: no region pair group
lmod1 <- lFormula(fst_emp~fst_sim+(1|sitenames), data=fst_all_sim, REML=FALSE) ## create the model
lmod1$reTrms$Zt <- lmod1$reTrms$Ztlist[[1]] <- Matrix(t(W))  ## give the actual model matrix Zt to the model
devfun1 <- do.call(mkLmerDevfun, lmod1) ## makes a deviance function
opt1 <- optimizeLmer(devfun1) ## takes a deviance function and optimizes over theta
m1 <- mkMerMod(environment(devfun1), opt1, lmod1$reTrms, fr = lmod1$fr) ## produces a lmerMod object from previous steps

## model 2: region pair group included as a predictor: group A (B-atolls) and group B (within-B, within-region)
lmod2 <- lFormula(fst_emp~fst_sim+regions_grp_2+fst_sim*regions_grp_2+(1|sitenames), data=fst_all_sim, REML=FALSE) ## create the model
lmod2$reTrms$Zt <- lmod2$reTrms$Ztlist[[1]] <- Matrix(t(W))  ## give the actual model matrix Zt to the model
devfun2 <- do.call(mkLmerDevfun, lmod2) ## makes a deviance function
opt2 <- optimizeLmer(devfun2) ## takes a deviance function and optimizes over theta
m2 <- mkMerMod(environment(devfun2), opt2, lmod2$reTrms, fr = lmod2$fr) ## produces a lmerMod object from previous steps

## model 3: region pair group included as a predictor: group C (B-atolls, within-B) and group D (within-region)
lmod3 <- lFormula(fst_emp~fst_sim+regions_grp_3+fst_sim*regions_grp_3+(1|sitenames), data=fst_all_sim, REML=FALSE) ## create the model
lmod3$reTrms$Zt <- lmod3$reTrms$Ztlist[[1]] <- Matrix(t(W))  ## give the actual model matrix Zt to the model
devfun3 <- do.call(mkLmerDevfun, lmod3) ## makes a deviance function
opt3 <- optimizeLmer(devfun3) ## takes a deviance function and optimizes over theta
m3 <- mkMerMod(environment(devfun3), opt3, lmod3$reTrms, fr = lmod3$fr) ## produces a lmerMod object from previous steps

## model 4: region pair group included as a predictor
lmod4 <- lFormula(fst_emp~fst_sim+regions_grp+fst_sim*regions_grp+(1|sitenames), data=fst_all_sim, REML=FALSE) ## create the model
lmod4$reTrms$Zt <- lmod4$reTrms$Ztlist[[1]] <- Matrix(t(W))  ## give the actual model matrix Zt to the model
devfun4 <- do.call(mkLmerDevfun, lmod4) ## makes a deviance function
opt4 <- optimizeLmer(devfun4) ## takes a deviance function and optimizes over theta
m4 <- mkMerMod(environment(devfun4), opt4, lmod4$reTrms, fr = lmod4$fr) ## produces a lmerMod object from previous steps

anova(m1,m3,m4)
anova(m1,m2,m4)

```


```{r}
coefs_alldata <- as.data.frame(summary(m4)$coefficients) %>% rownames_to_column()
CI_alldata <- as.data.frame(confint(m4)) %>% rownames_to_column()
coefs_alldata <- left_join(coefs_alldata,CI_alldata,by='rowname')
colnames(coefs_alldata) <- c('rowname','est','se','t','l95','u95')

fit_to_grp_alldata <- data.frame(grp=factor(c('1','2','3')), slope=NA, intercept=NA)
fit_to_grp_alldata$intercept=c(coefs_alldata$est[1],coefs_alldata$est[1]+coefs_alldata$est[3],coefs_alldata$est[1]+coefs_alldata$est[4])
fit_to_grp_alldata$slope=c(coefs_alldata$est[2],coefs_alldata$est[2]+coefs_alldata$est[5],coefs_alldata$est[2]+coefs_alldata$est[6])
```

```{r}
## Now make a plot with the fitted lines on it:
fst_summary <- fst_summary %>%
  mutate(regions_grp=factor(case_match(both_regions, 
                                c('CG','GN','GT','CL','LN','LT','GL')~1, c('CN','CT','NT')~2, c('NN','CC','TT','GG','LL')~3)))

# overview: all points
colors_all=c('1'="#66CCEE",'2'="#CCBB44",'3'="#AA3377")
ggplot(fst_summary,aes(y=fst_emp,x=mean))+
  geom_errorbar(aes(xmin=mean-sd,xmax=mean+sd, color=regions_grp),position = position_jitter(seed = 100), alpha=0.15)+
  geom_point(aes(color=regions_grp), position = position_jitter(seed = 100))+
  geom_abline(aes(slope=1,intercept=0))+
  theme_bw()+
  scale_color_manual(values=colors_all)+
  #labs(y = "empirical FST", x="simulated FST (mean+/-sd over 7500 generations)")+
  coord_fixed()+
  theme(legend.position="none",axis.title.x=element_blank(),axis.title.y=element_blank())

# group 1: N/C/T <--> G <--> L
shapes_1=c('GL'=8,'CG'=0,'GN'=1,'GT'=2,'CL'=15,'LN'=16,'LT'=17)
fst_summary %>%
  filter(regions_grp==1) %>%
  mutate(both_regions=factor(both_regions,levels=c('CL','LN','LT','CG','GN','GT','GL'))) %>%
  ggplot(aes(y=fst_emp,x=mean))+
    geom_errorbar(aes(xmin=mean-sd,xmax=mean+sd),color=colors_all[1],position = position_jitter(seed = 100), alpha=0.15)+
    geom_point(aes(shape=both_regions),color=colors_all[1],fill=colors_all[1],position = position_jitter(seed = 100))+
    geom_abline(aes(slope=1,intercept=0))+
    geom_abline(aes(slope=fit_to_grp_alldata$slope[1],intercept=fit_to_grp_alldata$intercept[1]),color=colors_all[1])+
    theme_bw()+
    #theme(panel.border=element_rect(colour=colors_all[1], fill=NA, linewidth=2))+
    theme(legend.position = c(0.89,0.76),legend.background=element_rect(fill='white',size=0.5),legend.title=element_blank())+
    theme(legend.title=element_blank(),axis.title.x=element_blank(),axis.title.y=element_blank())+
    scale_shape_manual(values=shapes_1)+
    #labs(y = "empirical FST", x="simulated FST (mean+/-sd over 7500 generations)")+
    #guides(shape=guide_legend(ncol=3, byrow=TRUE))+
    coord_fixed()

# group 2: N <--> C <--> T
shapes_2=c('CN'=8,'NT'=1,'CT'=16)
fst_summary %>%
  filter(regions_grp==2) %>%
  mutate(both_regions=factor(both_regions,levels=c('CN','NT','CT'))) %>%
  ggplot(aes(y=fst_emp,x=mean))+
    geom_errorbar(aes(xmin=mean-sd,xmax=mean+sd),color=colors_all[2],position = position_jitter(seed = 100), alpha=0.15)+
    geom_point(aes(shape=both_regions),color=colors_all[2],fill=colors_all[2],position = position_jitter(seed = 100))+
    geom_abline(aes(slope=1,intercept=0))+
      geom_abline(aes(slope=fit_to_grp_alldata$slope[2],intercept=fit_to_grp_alldata$intercept[2]),color=colors_all[2])+  
  theme_bw()+
    #theme(panel.border=element_rect(colour=colors_all[2], fill=NA, linewidth=2))+
    theme(legend.position = c(0.89,0.72),legend.background=element_rect(fill='white',size=0.5),legend.title=element_blank())+
    theme(legend.title=element_blank(),axis.title.x=element_blank(),axis.title.y=element_blank())+
    scale_shape_manual(values=shapes_2)+
    #labs(y = "empirical FST", x="simulated FST (mean+/-sd over 7500 generations)")+
    #guides(shape=guide_legend(ncol=3, byrow=TRUE))+
    coord_fixed()

# group 3: withins
shapes_3=c('CC'=0,'NN'=2,'TT'=8,'GG'=16,'LL'=17)
fst_summary %>%
  filter(regions_grp==3) %>%
  mutate(both_regions=factor(both_regions,levels=c('NN','CC','TT','LL','GG'))) %>%
  ggplot(aes(y=fst_emp,x=mean))+
    geom_errorbar(aes(xmin=mean-sd,xmax=mean+sd),color=colors_all[3],position = position_jitter(seed = 100), alpha=0.15)+
    geom_point(aes(shape=both_regions),color=colors_all[3],fill=colors_all[3],position = position_jitter(seed = 100))+
    geom_abline(aes(slope=1,intercept=0))+
      geom_abline(aes(slope=fit_to_grp_alldata$slope[3],intercept=fit_to_grp_alldata$intercept[3]),color=colors_all[3])+  
  theme_bw()+
    #theme(panel.border=element_rect(colour=colors_all[3], fill=NA, linewidth=2))+
    theme(legend.position = c(0.89,0.68),legend.background=element_rect(fill='white',size=0.5),legend.title=element_blank())+
    theme(legend.title=element_blank(),axis.title.x=element_blank(),axis.title.y=element_blank())+
    scale_shape_manual(values=shapes_3)+
    #labs(y = "empirical FST", x="simulated FST (mean+/-sd over 7500 generations)")+
    #guides(shape=guide_legend(ncol=3, byrow=TRUE))+
    coord_fixed()

```

### Old
For now, I'm just using the mean value (simulated over time) for each site pair as the predictor. Accounting for nonindependence b/c of reuse of sites using a multiple membership (i.e., cross-classified) model.
```{r}
fst_data <- left_join(fst_summary, fst_emp,by='sites') %>%
  dplyr::select(sites,x=mean,y=fst) %>%
  mutate(site1=str_split_i(sites,"\\.",1)) %>%
  mutate(site2=str_split_i(sites,"\\.",2))

site_list <- unique(c(fst_data$site1,fst_data$site2))

## make model matrix W
W = matrix(nrow=nrow(fst_data),ncol=length(site_list))
colnames(W) = site_list
rownames(W) = fst_data$sites
for(i in 1:nrow(W)){
  for(j in 1:ncol(W)){
    W[i,j] = ifelse((site_list[j] == fst_data$site1[i]) | (site_list[j] == fst_data$site2[i]), 1, 0)
  } # j (sites)
} # i (site pairs) 
```

Code from https://bbolker.github.io/mixedmodels-misc/notes/multimember.html:
```{r modular_fit}
## helpful to specify a factor with the right levels:
## actual values are unimportant since we will specify Zt/Ztlist directly
fst_data$fake <- rep(site_list,length.out=nrow(fst_data)) ## make a dummy column with the right item names
lmod <- lFormula(y~x+(1|fake), data=fst_data) ## create the model
lmod$reTrms$Zt <- lmod$reTrms$Ztlist[[1]] <- Matrix(t(W))  ## give the actual model matrix Zt to the model
devfun <- do.call(mkLmerDevfun, lmod) ## makes a deviance function
opt <- optimizeLmer(devfun) ## takes a deviance function and optimizes over theta
m1 <- mkMerMod(environment(devfun), opt, lmod$reTrms, fr = lmod$fr) ## produces a lmerMod object from previous steps

summary(m1)
```

```{r plotresults}
dd <- tidy(m1, effects="ran_vals")
dd <- transform(dd, level=reorder(level,estimate))
ggplot(dd,aes(x=level,y=estimate))+
    geom_pointrange(aes(ymin=estimate-2*std.error,
              ymax=estimate+2*std.error))+coord_flip()
```
### Variance explained: 
Why can't we just use "regular R^2"? It doesn't account for the random effects. Lots of options, including:

#### Nakagawa and Schielzeth's pseudo-R^2
I think I'll go with this, since it's easily citable. 
Marginal and conditional pseudo-R^2 for GLMMs from Nakagawa and Schielzeth 2012: https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/j.2041-210x.2012.00261.x

Here are the values we get:
```{r}
r2 <- r.squaredGLMM(m1)
r2
```

##### More info:
marginal = fixed effects (here, SLiM simulation value) only
conditional = entire model, including fixed and random (here, site ID) effects

$$
R^2_m = \frac{\sigma^2_f}{\sigma^2_f+\sigma^2_\alpha+\sigma^2_\epsilon} \\

R^2_c = \frac{\sigma^2_f+\sigma^2_\alpha}{\sigma^2_f+\sigma^2_\alpha+\sigma^2_\epsilon}

$$
where $\sigma^2_f$ = variance of fixed effect components
$\sigma^2_\alpha$ = variance of random effects
$\sigma^2_\epsilon$ = "observation-level" variance

They recommend presenting both marginal and conditional in publications. I think conditional is the most relevant here, because we know the site-level info, and want to do the best job we can at relating SLiM values to empirical values. 

#### Quick idea from Bolker
Bolker has a discussion of this issue: https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html#how-do-i-compute-a-coefficient-of-determination-r2-or-an-analogue-for-glmms

One idea he suggests is the squared correlation between the response variable (here, empirical FST) and the predicted values (here, the output from the statistical model, given the SLiM value and the site memberships):
```{r}
df_plot <- data.frame(resp=model.response(model.frame(m1)),
                      pred=predict(m1,type="response"))

var_expl <- (cor(df_plot$resp,df_plot$pred))^2
var_expl

ggplot(data=df_plot,aes(x=pred,y=resp))+
  geom_point()+
  labs(x="model prediction",y="empirical value")+
  annotate("text",x = 0, y = 0.0275, label = paste("variance explained: \n",round(var_expl,3)))+
  theme_minimal()
```

###Variance explained against a 1-1 line: (https://www.css.cornell.edu/faculty/dgr2/_static/files/R_html/ModelEvaluation.html)
Also think about out-of-sample prediction?
```{r}
numerator <- sum((df_plot$resp-df_plot$pred)^2)
denominator <- sum((df_plot$resp-mean(df_plot$resp))^2)
r2 <- 1-numerator/denominator
```



## Predicted vs observed FST: Residuals

### Broad-scale

```{r}
fst_rmse <- left_join(fst_all_sim, fst_emp, by='sites') %>%
  rename(fst_sim=fst.x, fst_emp=fst.y) %>%
  filter(!is.na(fst_emp), tick>=2500) %>%
  group_by(tick,both_pops) %>%
  summarize(dev=median(fst_emp-fst_sim), dev_q025=quantile(fst_emp-fst_sim,0.025),dev_q975=quantile(fst_emp-fst_sim, 0.975))

ggplot(fst_rmse,aes(x=tick,y=dev,color=both_pops))+
  geom_point()+
  geom_errorbar(aes(ymin=dev_q025,ymax=dev_q975,color=both_pops))+
  ylab('fst_emp-fst_sim (median and 95% quantiles)')+
  geom_line()+
  geom_hline(aes(yintercept=0))+
  facet_wrap(vars(both_pops))
```


```{r}
all_fst <- left_join(fst_all_sim, fst_emp, by='sites') %>%
  rename(fst_sim=fst.x, fst_emp=fst.y) %>%
  filter(!is.na(fst_emp), tick>=2500) %>%
  mutate(resid=fst_emp-fst_sim)

# I don't like this one, because it treats points within the same pop group as equally related, no matter what site pair or tick they belong to
ggplot(all_fst,aes(x=both_pops,y=resid, fill=both_pops))+
  geom_violin()+
  geom_hline(aes(yintercept=0))

# this takes the median within each pop group at each tick, and plots the distribution of medians over all ticks. so the distributions are more restricted, and we don't get any sense of spread within the pop group.
all_fst %>% group_by(both_pops,tick) %>%
  summarize(resid_med=median(resid),resid_q025=quantile(resid,0.025),resid_q975=quantile(resid,0.975)) %>%
  ggplot(aes(x=both_pops,y=resid_med, fill=both_pops))+
  geom_violin()+
  geom_hline(aes(yintercept=0))
```


```{r}
# this model doesn't control for nonindependence among data points by shared sites. s.e.'s are much tighter. Using the one that follows is better.
fst_rmse_formodel <- left_join(fst_all_sim, fst_emp, by='sites') %>%
  rename(fst_sim=fst.x, fst_emp=fst.y) %>%
  filter(!is.na(fst_emp), tick>=2500) %>%
  mutate(dev=fst_emp-fst_sim)

dev_model <- lm(dev~both_pops+tick, data=fst_rmse_formodel)
dev_model

coefs <- as.data.frame(summary(dev_model)$coefficients) %>%
  mutate(var=c('BB','BG','BL','GG','GL','LL','tick'))
colnames(coefs) <- c('Estimate','se','t','p','var')

ggplot(coefs,aes(x=var,y=Estimate, color=var))+
  geom_point()+
  geom_errorbar(aes(ymin=Estimate-se,ymax=Estimate+se))+
  geom_hline(aes(yintercept=0))
```


```{r}
fst_resid_data <- left_join(fst_all_sim, fst_emp, by='sites') %>%
  rename(fst_sim=fst.x, fst_emp=fst.y) %>%
  filter(!is.na(fst_emp), tick>=2500) %>%
  mutate(resid=fst_emp-fst_sim)
site_list <- unique(c(fst_resid_data$site1,fst_resid_data$site2))

## make model matrix W
W = matrix(nrow=nrow(fst_resid_data),ncol=length(site_list))
colnames(W) = site_list
rownames(W) = fst_resid_data$sites
for(i in 1:nrow(W)){
  for(j in 1:ncol(W)){
    W[i,j] = ifelse((site_list[j] == fst_resid_data$site1[i]) | (site_list[j] == fst_resid_data$site2[i]), 1, 0)
  } # j (sites)
} # i (site pairs) 

fst_resid_data$sitenames <- rep(site_list,length.out=nrow(fst_resid_data)) ## make a dummy column with the right item names
lmod <- lFormula(resid~both_pops+(1|sitenames), data=fst_resid_data) ## create the model
lmod$reTrms$Zt <- lmod$reTrms$Ztlist[[1]] <- Matrix(t(W))  ## give the actual model matrix Zt to the model
devfun <- do.call(mkLmerDevfun, lmod) ## makes a deviance function
opt <- optimizeLmer(devfun) ## takes a deviance function and optimizes over theta
m1 <- mkMerMod(environment(devfun), opt, lmod$reTrms, fr = lmod$fr) ## produces a lmerMod object from previous steps

m1
a <- summary(m1)

summary(m1)$coefficients

coefs <- as.data.frame(summary(m1)$coefficients) %>%
  mutate(var=c('BB','BG','BL','GG','GL','LL'))
colnames(coefs) <- c('Estimate','se','t','var')

ggplot(coefs,aes(y=var,x=Estimate, color=var))+
  geom_point()+
  geom_linerange(aes(xmin=Estimate-se,xmax=Estimate+se), lwd=1.2)+
  geom_vline(aes(xintercept=0))+
  xlab('Estimate +/- s.e.')+
  ylab('Population pair')+
  scale_y_discrete(limits=rev)+
  theme_minimal()+
  theme(legend.position="none")
```

### Broad-scale, separate Turneffe

```{r}
fst_dev_turneffe <- left_join(fst_all_sim, fst_emp, by='sites') %>%
  rename(fst_sim=fst.x, fst_emp=fst.y) %>%
  filter(!is.na(fst_emp), tick>=2500) %>%
  mutate(pop1.T=case_match(region1,"T"~"T","N"~"B","C"~"B",.default=pop1)) %>%
  mutate(pop2.T=case_match(region2,"T"~"T","N"~"B","C"~"B",.default=pop2)) %>%
  mutate(region1.T=case_match(site1,c("T1","T6","T5","T4")~"W",c("T2","T3")~"E",.default=region1)) %>% # think about how to divide them...
  mutate(region2.T=case_match(site2,c("T1","T6","T5","T4")~"W",c("T2","T3")~"E",.default=region2))

## add both_pops column (in alphabetical order, so we don't have e.g. BG and GB)
fst_dev_turneffe$both_pops_T <- NA
for(j in 1:nrow(fst_dev_turneffe)){
  fst_dev_turneffe$both_pops_T[j] <- paste0(sort(as.matrix(fst_dev_turneffe[j,c('pop1.T','pop2.T')])), collapse='')
}

## add both_regions column (also in alphabetical order)
fst_dev_turneffe$both_regions_T <- NA
for(j in 1:nrow(fst_dev_turneffe)){
  if(!is.na(fst_dev_turneffe$region1.T[j]) & !is.na(fst_dev_turneffe$region2.T[j])){
    fst_dev_turneffe$both_regions_T[j] <- paste(sort(as.matrix(fst_dev_turneffe[j,c('region1.T','region2.T')])), collapse='')
  }
}


big_plot_turneffe <- fst_dev_turneffe %>%
  group_by(sites) %>%
  summarize(median=median(fst_sim), mean=mean(fst_sim), sd = sd(fst_sim), q95_low=quantile(fst_sim,0.025),
            q95_up=quantile(fst_sim,0.975),both_pops_T=first(both_pops_T),both_regions_T=first(both_regions_T)) %>%
  left_join(fst_emp,by='sites') %>%
  rename(fst_emp=fst) %>%
  filter(!is.na(fst_emp))
ggplot(big_plot_turneffe,aes(x=fst_emp,y=mean))+
  geom_errorbar(aes(ymin=mean-sd,ymax=mean+sd, color=both_pops_T),position = position_jitter(seed = 100), alpha=0.15)+
  geom_point(aes(color=both_pops_T), position = position_jitter(seed = 100))+
  geom_abline(aes(slope=1,intercept=0))+
  theme_minimal()+
  xlim(c(-0.005, 0.032))+
  ylim(c(-0.005, 0.032))+
  labs(x = "empirical FST", y="simulated FST (mean+/-sd over 7500 generations)")+
  coord_flip()

fst_dev_turneffe_lg <- fst_dev_turneffe %>%
  group_by(tick,both_pops_T) %>%
  summarize(dev=median(fst_emp-fst_sim), dev_q025=quantile(fst_emp-fst_sim,0.025),dev_q975=quantile(fst_emp-fst_sim, 0.975))

ggplot(fst_dev_turneffe_lg,aes(x=tick,y=dev,color=both_pops_T))+
  geom_point()+
  geom_errorbar(aes(ymin=dev_q025,ymax=dev_q975,color=both_pops_T))+
  ylab('fst_emp-fst_sim (median and 95% quantiles)')+
  geom_line()+
  geom_hline(aes(yintercept=0))+
  facet_wrap(vars(both_pops_T))
```

```{r}
fst_dev_turneffe <- fst_dev_turneffe %>%
  mutate(resid=fst_emp-fst_sim)

site_list <- unique(c(fst_dev_turneffe$site1,fst_dev_turneffe$site2))

## make model matrix W
W = matrix(nrow=nrow(fst_dev_turneffe),ncol=length(site_list))
colnames(W) = site_list
rownames(W) = fst_dev_turneffe$sites
for(i in 1:nrow(W)){
  for(j in 1:ncol(W)){
    W[i,j] = ifelse((site_list[j] == fst_dev_turneffe$site1[i]) | (site_list[j] == fst_dev_turneffe$site2[i]), 1, 0)
  } # j (sites)
} # i (site pairs) 

fst_dev_turneffe$sitenames <- rep(site_list,length.out=nrow(fst_dev_turneffe)) ## make a dummy column with the right item names
lmod <- lFormula(resid~both_pops_T+(1|sitenames), data=fst_dev_turneffe) ## create the model
lmod$reTrms$Zt <- lmod$reTrms$Ztlist[[1]] <- Matrix(t(W))  ## give the actual model matrix Zt to the model
devfun <- do.call(mkLmerDevfun, lmod) ## makes a deviance function
opt <- optimizeLmer(devfun) ## takes a deviance function and optimizes over theta
m1 <- mkMerMod(environment(devfun), opt, lmod$reTrms, fr = lmod$fr) ## produces a lmerMod object from previous steps

m1
a <- summary(m1)

summary(m1)$coefficients

coefs <- as.data.frame(summary(m1)$coefficients) %>%
  mutate(var=c('BB','BG','BL','BT','GG','GL','GT','LL','LT','TT'))
colnames(coefs) <- c('Estimate','se','t','var')

ggplot(coefs,aes(y=var,x=Estimate, color=var))+
  geom_point()+
  geom_linerange(aes(xmin=Estimate-se,xmax=Estimate+se), lwd=1.2)+
  geom_vline(aes(xintercept=0))+
  xlab('Estimate +/- s.e.')+
  ylab('Region pair')+
  scale_y_discrete(limits=rev)+
  theme_minimal()+
  theme(legend.position="none")
```

### Fine-scale

```{r}

cols_fine <- c("NN"="#01665e", "CC"="#5ab4ac", "TT"="#8c510a", "CN"="#c7eae5", "NT"="#d8b365",  "CT"="#f6e8c3")

fst_dev_fine <- left_join(fst_all_sim, fst_emp, by='sites') %>%
  rename(fst_sim=fst.x, fst_emp=fst.y) %>%
  filter(!is.na(fst_emp), tick>=2500, !is.na(both_regions)) %>%
  group_by(tick,both_regions) %>%
  summarize(dev=median(fst_emp-fst_sim), dev_q025=quantile(fst_emp-fst_sim,0.025),dev_q975=quantile(fst_emp-fst_sim, 0.975))

ggplot(fst_dev_fine,aes(x=tick,y=dev,color=both_regions))+
  geom_point()+
  geom_errorbar(aes(ymin=dev_q025,ymax=dev_q975,color=both_regions))+
  scale_color_discrete_qualitative(palette="Harmonic")+
  ylab('fst_emp-fst_sim (median and 95% quantiles)')+
  geom_line()+
  geom_hline(aes(yintercept=0))+
  facet_wrap(vars(both_regions))
```

```{r}
fst_resid_data_fine <- filter(fst_resid_data, !is.na(both_regions))
site_list <- unique(c(fst_resid_data_fine$site1,fst_resid_data_fine$site2))

## make model matrix W
W = matrix(nrow=nrow(fst_resid_data_fine),ncol=length(site_list))
colnames(W) = site_list
rownames(W) = fst_resid_data_fine$sites
for(i in 1:nrow(W)){
  for(j in 1:ncol(W)){
    W[i,j] = ifelse((site_list[j] == fst_resid_data_fine$site1[i]) | (site_list[j] == fst_resid_data_fine$site2[i]), 1, 0)
  } # j (sites)
} # i (site pairs) 

fst_resid_data_fine$sitenames <- rep(site_list,length.out=nrow(fst_resid_data_fine)) ## make a dummy column with the right item names
lmod <- lFormula(resid~both_regions+(1|sitenames), data=fst_resid_data_fine) ## create the model
lmod$reTrms$Zt <- lmod$reTrms$Ztlist[[1]] <- Matrix(t(W))  ## give the actual model matrix Zt to the model
devfun <- do.call(mkLmerDevfun, lmod) ## makes a deviance function
opt <- optimizeLmer(devfun) ## takes a deviance function and optimizes over theta
m1 <- mkMerMod(environment(devfun), opt, lmod$reTrms, fr = lmod$fr) ## produces a lmerMod object from previous steps

m1
a <- summary(m1)

summary(m1)$coefficients

coefs <- as.data.frame(summary(m1)$coefficients) %>%
  mutate(var=c('CC','CN','CT','NN','NT','TT'))
colnames(coefs) <- c('Estimate','se','t','var')

ggplot(coefs,aes(y=var,x=Estimate, color=var))+
  geom_point()+
  geom_linerange(aes(xmin=Estimate-se,xmax=Estimate+se), lwd=1.2)+
  scale_color_discrete_qualitative(palette="Harmonic")+
  geom_vline(aes(xintercept=0))+
  xlab('Estimate +/- s.e.')+
  ylab('Region pair')+
  scale_y_discrete(limits=rev)+
  theme_minimal()+
  theme(legend.position="none")
```

### Fine-scale, separate Turneffe

```{r}
ggplot(filter(big_plot_turneffe,!is.na(both_regions_T)),aes(x=fst_emp,y=mean))+
  geom_errorbar(aes(ymin=mean-sd,ymax=mean+sd, color=both_regions_T),position = position_jitter(seed = 100), alpha=0.15)+
  geom_point(aes(color=both_regions_T), position = position_jitter(seed = 100))+
  scale_color_discrete_qualitative(palette="Harmonic")+
  geom_abline(aes(slope=1,intercept=0))+
  theme_minimal()+
  labs(x = "empirical FST", y="simulated FST (mean+/-sd over 7500 generations)")+
  coord_flip()

fst_dev_turneffe_sm <- filter(fst_dev_turneffe,!is.na(both_regions_T)) %>%
  group_by(tick,both_regions_T) %>%
  summarize(dev=median(fst_emp-fst_sim), dev_q025=quantile(fst_emp-fst_sim,0.025),dev_q975=quantile(fst_emp-fst_sim, 0.975))

ggplot(fst_dev_turneffe_sm,aes(x=tick,y=dev,color=both_regions_T))+
  geom_point()+
  geom_errorbar(aes(ymin=dev_q025,ymax=dev_q975,color=both_regions_T))+
  scale_color_discrete_qualitative(palette="Harmonic")+
  ylab('fst_emp-fst_sim (median and 95% quantiles)')+
  geom_line()+
  geom_hline(aes(yintercept=0))+
  facet_wrap(vars(both_regions_T))
```

```{r}
fst_dev_turneffe <- fst_dev_turneffe %>%
  filter(!is.na(both_regions_T))

site_list <- unique(c(fst_dev_turneffe$site1,fst_dev_turneffe$site2))

## make model matrix W
W = matrix(nrow=nrow(fst_dev_turneffe),ncol=length(site_list))
colnames(W) = site_list
rownames(W) = fst_dev_turneffe$sites
for(i in 1:nrow(W)){
  for(j in 1:ncol(W)){
    W[i,j] = ifelse((site_list[j] == fst_dev_turneffe$site1[i]) | (site_list[j] == fst_dev_turneffe$site2[i]), 1, 0)
  } # j (sites)
} # i (site pairs) 

fst_dev_turneffe$sitenames <- rep(site_list,length.out=nrow(fst_dev_turneffe)) ## make a dummy column with the right item names
lmod <- lFormula(resid~both_regions_T+(1|sitenames), data=fst_dev_turneffe) ## create the model
lmod$reTrms$Zt <- lmod$reTrms$Ztlist[[1]] <- Matrix(t(W))  ## give the actual model matrix Zt to the model
devfun <- do.call(mkLmerDevfun, lmod) ## makes a deviance function
opt <- optimizeLmer(devfun) ## takes a deviance function and optimizes over theta
m1 <- mkMerMod(environment(devfun), opt, lmod$reTrms, fr = lmod$fr) ## produces a lmerMod object from previous steps

m1
a <- summary(m1)

summary(m1)$coefficients

coefs <- as.data.frame(summary(m1)$coefficients) %>%
  mutate(var=c('CC','CE','CN','CW','EE','EN','EW','NN','NW','WW'))
colnames(coefs) <- c('Estimate','se','t','var')

ggplot(coefs,aes(y=var,x=Estimate, color=var))+
  geom_point()+
  geom_linerange(aes(xmin=Estimate-se,xmax=Estimate+se), lwd=1.2)+
  scale_color_discrete_qualitative(palette="Harmonic")+
  geom_vline(aes(xintercept=0))+
  xlab('Estimate +/- s.e.')+
  ylab('Region pair')+
  scale_y_discrete(limits=rev)+
  theme_minimal()+
  theme(legend.position="none")
```


### One scale: N C T G L

#### Simulated vs empirical FST
```{r}
region_pairs <- unique(fst_all_sim$both_regions)
region_pairs_within <- c('NN','CC','GG','TT','LL')
region_pairs_barrier <- c('CN','NT','CT')
region_pairs_among <- c('LN','CL','GN','CG','GL','LT','GT')

ggplot(fst_summary,aes(x=fst_emp,y=mean))+
  geom_errorbar(aes(ymin=mean-sd,ymax=mean+sd, color=both_regions),position = position_jitter(seed = 100), alpha=0.15)+
  geom_point(aes(color=both_regions), position = position_jitter(seed = 100))+
  geom_abline(aes(slope=1,intercept=0))+
  theme_minimal()+
  xlim(c(-0.005, 0.032))+
  ylim(c(-0.005, 0.032))+
  labs(x = "empirical FST", y="simulated FST (mean+/-sd over 7500 generations)")+
  coord_flip()
```


#### Residual dynamics by region pair
```{r}
resid_dynamics <- filter(fst_all_sim,tick>2500) %>%
  group_by(tick,both_regions) %>%
  summarize(dev=median(fst_emp-fst_sim), dev_q025=quantile(fst_emp-fst_sim,0.025),dev_q975=quantile(fst_emp-fst_sim, 0.975))

ggplot(resid_dynamics,aes(x=tick,y=dev))+
  geom_point()+
  geom_errorbar(aes(ymin=dev_q025,ymax=dev_q975))+
  ylab('fst_emp-fst_sim (median and 95% quantiles)')+
  geom_line()+
  geom_hline(aes(yintercept=0))+
  facet_wrap(vars(both_regions))
```
#### Effect of region pair on residual

```{r}
fst_resid_data <- filter(fst_all_sim, tick>=2500) %>%
  mutate(resid=fst_emp-fst_sim)
site_list <- unique(c(fst_resid_data$site1,fst_resid_data$site2))

## make model matrix W
W = matrix(nrow=nrow(fst_resid_data),ncol=length(site_list))
colnames(W) = site_list
rownames(W) = fst_resid_data$sites
for(i in 1:nrow(W)){
  for(j in 1:ncol(W)){
    W[i,j] = ifelse((site_list[j] == fst_resid_data$site1[i]) | (site_list[j] == fst_resid_data$site2[i]), 1, 0)
  } # j (sites)
} # i (site pairs) 

fst_resid_data$sitenames <- rep(site_list,length.out=nrow(fst_resid_data)) ## make a dummy column with the right item names
lmod <- lFormula(resid~both_regions+(1|sitenames), data=fst_resid_data) ## create the model
lmod$reTrms$Zt <- lmod$reTrms$Ztlist[[1]] <- Matrix(t(W))  ## give the actual model matrix Zt to the model
devfun <- do.call(mkLmerDevfun, lmod) ## makes a deviance function
opt <- optimizeLmer(devfun) ## takes a deviance function and optimizes over theta
m1 <- mkMerMod(environment(devfun), opt, lmod$reTrms, fr = lmod$fr) ## produces a lmerMod object from previous steps

## parametric CIs
CI_param <- confint(m1)
CI_param <- as.data.frame(CI_param[-c(1,2),]) %>%
  mutate(var=c('CC','CG','CL','CN','CT','GG','GL','GN','GT','LL','LN','LT','NN','NT','TT'))

coefs <- as.data.frame(summary(m1)$coefficients) %>%
  mutate(var=c('CC','CG','CL','CN','CT','GG','GL','GN','GT','LL','LN','LT','NN','NT','TT')) %>%
  left_join(CI_param,by='var') %>%
  arrange(Estimate) %>%
  mutate(var=factor(var,levels=var))
colnames(coefs) <- c('Estimate','se','t','var','l_95','u_95')

ggplot(coefs,aes(y=var,x=Estimate))+
  geom_point(size=2)+
  geom_linerange(aes(xmin=l_95,xmax=u_95), lwd=1.2)+
  geom_vline(aes(xintercept=0))+
  xlab('Estimate +/- s.e.')+
  ylab('Population pair')+
  theme_minimal()
```

```{r}
## bootstrap CI's for region pair effect sizes
## bootstrap CI's are much wider than parametric ones. I don't immediately understand why, but to be conservative we'll use the parametric ones for now.


boot_ests <- coefs %>% 
  rownames_to_column(var="effect") %>%
  dplyr::select(effect,var,real_Est=Estimate)

for(nboot in 1:100){
  pick <- sample(nrow(fst_resid_data),size=nrow(fst_resid_data),replace=TRUE)
  data_boot <- fst_resid_data[pick,]
  site_list_boot <- unique(c(data_boot$site1,data_boot$site2))
  
  ## make model matrix W
  W = matrix(nrow=nrow(data_boot),ncol=length(site_list_boot))
  colnames(W) = site_list_boot
  rownames(W) = data_boot$sites
  for(i in 1:nrow(W)){
    for(j in 1:ncol(W)){
      W[i,j] = ifelse((site_list_boot[j] == data_boot$site1[i]) | (site_list_boot[j] == data_boot$site2[i]), 1, 0)
    } # j (sites)
  } # i (site pairs) 
  
  data_boot$sitenames <- rep(site_list_boot,length.out=nrow(data_boot)) ## make a dummy column with the right item names
  lmod <- lFormula(resid~both_regions+(1|sitenames), data=data_boot) ## create the model
  lmod$reTrms$Zt <- lmod$reTrms$Ztlist[[1]] <- Matrix(t(W))  ## give the actual model matrix Zt to the model
  devfun <- do.call(mkLmerDevfun, lmod) ## makes a deviance function
  opt <- optimizeLmer(devfun) ## takes a deviance function and optimizes over theta
  m1_boot <- mkMerMod(environment(devfun), opt, lmod$reTrms, fr = lmod$fr) ## produces a lmerMod object from previous steps
  
  coefs_boot <- dplyr::select(as.data.frame(summary(m1_boot)$coefficients),Estimate) %>% rownames_to_column(var="effect")
  boot_ests <- left_join(boot_ests,coefs_boot,by='effect')
}

boot_ests_df <- as.data.frame(t(boot_ests))
rownames(boot_ests_df) <- NULL
colnames(boot_ests_df) <- boot_ests_df[2,]
est_names <- boot_ests_df[2,]
boot_ests_df <- boot_ests_df[-c(1,2,3),] # remove the real data
boot_ests_df <- sapply(boot_ests_df,as.numeric)
boot_ests_df <- as.data.frame(boot_ests_df)

boot_ests_lq <- sapply(boot_ests_df,FUN=quantile,0.025)
boot_ests_uq <- sapply(boot_ests_df,FUN=quantile,0.975)

CI_boot <- data.frame(t(est_names),lq_boot=boot_ests_lq,uq_boot=boot_ests_uq) %>%
  left_join(CI_param,by=join_by('X2'=='var'))
colnames(CI_boot)=c('region_pair','lq_boot','uq_boot','lq_param','uq_param')
CI_boot <- left_join(CI_boot,coefs,by=join_by('region_pair'=='var'))

ggplot(CI_boot,aes(y=region_pair,x=Estimate))+
  geom_point()+
  geom_errorbar(aes(xmin=lq_boot,xmax=uq_boot,color='boot'))+
  geom_errorbar(aes(xmin=lq_param,xmax=uq_param,color='param'))+
  geom_errorbar(aes(xmin=Estimate-se,xmax=Estimate+se,color='se'))+
  geom_vline(aes(xintercept=0))+
  xlab('Estimate +/- s.e.')+
  ylab('Population pair')+
  scale_y_discrete(limits=rev)+
  theme_minimal()

#save(boot_ests_df,file='boot_ests_df.RData') #took awhile to generate, so I'll save it in case I want it later
```


## Density plots

### Broad-scale
```{r}
fst_summary$both_pops <- factor(fst_summary$both_pops,levels=c('BB','GG','LL','BG','BL','GL'))

ggplot(data=fst_summary,aes(x=median,fill=both_pops,pattern_fill=both_pops,pattern_density=both_pops))+
  geom_density_pattern(pattern_spacing=0.03,alpha=0.6,pattern_alpha=0.6)+
  scale_pattern_density_manual(values=c(0,0,0,0.5,0.5,0.5),name='Populations')+
  scale_fill_manual(values=c('#91bfdb','#fc8d59','#ffffbf','#91bfdb','#91bfdb','#fc8d59'),name='Populations')+
  scale_pattern_fill_manual(values=c('#91bfdb','#fc8d59','#ffffbf','#fc8d59','#ffffbf','#ffffbf'),name='Populations')+
  theme_bw()+
  #theme(legend.position='bottom')+
  labs(x="Simulated FST")+
  xlim(c(0,0.035))+
  #ylim(c(0,2000))+
  guides(pattern_density = guide_legend(nrow = 3))

ggplot(data=fst_summary,aes(x=fst_emp,fill=both_pops,pattern_fill=both_pops,pattern_density=both_pops))+
  geom_density_pattern(pattern_spacing=0.03,alpha=0.6,pattern_alpha=0.6)+
  scale_pattern_density_manual(values=c(0,0,0,0.5,0.5,0.5),name='Populations')+
  scale_fill_manual(values=c('#91bfdb','#fc8d59','#ffffbf','#91bfdb','#91bfdb','#fc8d59'),name='Populations')+
  scale_pattern_fill_manual(values=c('#91bfdb','#fc8d59','#ffffbf','#fc8d59','#ffffbf','#ffffbf'),name='Populations')+
  theme_bw()+
  #theme(legend.position='bottom')+
  labs(x='Empirical FST')+
  ylim(c(0,2000))+
  xlim(c(0,0.035))+
  guides(pattern_density = guide_legend(nrow = 3))

ggplot(data=fst_summary,aes(x=median - fst_emp,fill=both_pops,pattern_fill=both_pops,pattern_density=both_pops))+
  geom_density_pattern(pattern_spacing=0.03,alpha=0.6,pattern_alpha=0.6)+
  scale_pattern_density_manual(values=c(0,0,0,0.5,0.5,0.5),name='Populations')+
  scale_fill_manual(values=c('#91bfdb','#fc8d59','#ffffbf','#91bfdb','#91bfdb','#fc8d59'),name='Populations')+
  scale_pattern_fill_manual(values=c('#91bfdb','#fc8d59','#ffffbf','#fc8d59','#ffffbf','#ffffbf'),name='Populations')+
  theme_bw()+
  #theme(legend.position='bottom')+
  labs(x='Simulated minus empirical FST')+
  guides(pattern_density = guide_legend(nrow = 3))

```


### Fine-scale
```{r}
fst_summary_sub <- filter(fst_summary,!is.na(both_regions)) %>%
  mutate(both_regions=factor(both_regions,levels=c('NN','CC','TT','CN','CT','NT')))

ggplot(data=fst_summary_sub,aes(x=median,fill=both_regions,pattern_fill=both_regions,pattern_density=both_regions))+
  geom_density_pattern(pattern_spacing=0.02,alpha=0.5,pattern_alpha=0.5)+
  scale_pattern_density_manual(values=c(0,0,0,0.5,0.5,0.5),name='Regions')+
  scale_fill_manual(values=c('#2b8cbe','#a6bddb','#ece7f2','#2b8cbe','#2b8cbe','#a6bddb'),name='Regions')+
  scale_pattern_fill_manual(values=c('#2b8cbe','#a6bddb','#ece7f2','#a6bddb','#ece7f2','#ece7f2'),name='Regions')+
  theme_bw()+
  #ylim(0,1000)+
  labs(x="Simulated FST")+
  guides(pattern_density = guide_legend(nrow = 3))

ggplot(data=fst_summary_sub,aes(x=fst_emp,fill=both_regions,pattern_fill=both_regions,pattern_density=both_regions))+
  geom_density_pattern(bw=0.0005,pattern_spacing=0.02,alpha=0.6,pattern_alpha=0.6)+ # try bw=0.0005 to remove lumpiness
  scale_pattern_density_manual(values=c(0,0,0,0.5,0.5,0.5),name='Regions')+
  scale_fill_manual(values=c('#2b8cbe','#a6bddb','#ece7f2','#2b8cbe','#2b8cbe','#a6bddb'),name='Regions')+
  scale_pattern_fill_manual(values=c('#2b8cbe','#a6bddb','#ece7f2','#a6bddb','#ece7f2','#ece7f2'),name='Regions')+
  theme_bw()+
  ylim(0,1000)+
  labs(x='Empirical FST')+
  guides(pattern_density = guide_legend(nrow = 3))

ggplot(data=fst_summary_sub,aes(x=median - fst_emp,fill=both_regions,pattern_fill=both_regions,pattern_density=both_regions))+
  geom_density_pattern(bw=0.0005,pattern_spacing=0.02,alpha=0.6,pattern_alpha=0.6)+ # try bw=0.0005 to remove lumpiness
  scale_pattern_density_manual(values=c(0,0,0,0.5,0.5,0.5),name='Regions')+
  scale_fill_manual(values=c('#2b8cbe','#a6bddb','#ece7f2','#2b8cbe','#2b8cbe','#a6bddb'),name='Regions')+
  scale_pattern_fill_manual(values=c('#2b8cbe','#a6bddb','#ece7f2','#a6bddb','#ece7f2','#ece7f2'),name='Regions')+
  theme_bw()+
  ylim(0,1000)+
  labs(x='Simulated minus Empirical FST')+
  guides(pattern_density = guide_legend(nrow = 3))
```

## IBD
Our simulated IBD slope is higher than the empirical one. (This is using data from North and Central Barrier only.)

```{r}
######
# we're making sure to use only the data from the N and C barrier
# and we're using the scaled fst values (fst/(1-fst))

load('../data/sitepair_dists.RData')
fst_dists <- left_join(filter(fst_all_sim,tick>2500),dplyr::select(sitepair_dists, sites,dist),by = 'sites', keep=FALSE) %>%
  mutate(scale_sim = fst_sim/(1-fst_sim)) %>%
  mutate(scale_emp = fst_emp/(1-fst_emp)) %>%
  dplyr::select(tick, sites,site1,site2,scale_sim,scale_emp,dist, both_regions) %>%
  filter(!is.na(dist) & both_regions%in%c('NN','CC','CN')) ## make sure to do this!! Otherwise we're using the atolls too

fst_summary_dists <- fst_dists %>%
  group_by(sites) %>%
  summarize(fst_sim_mean=mean(scale_sim),fst_sim_sd=sd(scale_sim),scale_emp=first(scale_emp),dist=first(dist))

site_list <- sort(unique(c(fst_dists$site1,fst_dists$site2)))
ticks <- unique(fst_dists$tick)
n_pts <- nrow(fst_summary_dists)
t_star <- qt(0.975,df=n_pts-2)

##############################################
## get simulated IBD slopes, with confidence intervals (bootstrap and parametric) and significance (mantel test)
##############################################
ibd_slopes_sim <- data.frame(tick=numeric(), ibd_slope=numeric(), slope_se=numeric(), ibd_r2=numeric(),
                             l_parametric=numeric(), u_parametric=numeric(), 
                             l_bootstrap = numeric(), u_bootstrap=numeric(),
                             l_pivot = numeric(), u_pivot=numeric(),
                             mantel_p=numeric(), mantel_r=numeric())

for(t in 1:length(ticks)){
  ## data to use for this tick
  fst_dists_t <- filter(fst_dists,tick==ticks[t])
  
  ## linear regression to get slope
  ibd_model_sim <- lm(scale_sim~dist,data=fst_dists_t)
  summ <- summary(ibd_model_sim)
  slope <- summ$coefficients[2,1]
  se <- summ$coefficients[2,2]
  r2 <- summ$adj.r.squared # adjusted R^2
  
  ## parametric slope CI
  l_param <- slope-t_star*se
  u_param <- slope+t_star*se
  
  ## boostrap slope CI
  slopes=vector()
  for(rep in 1:1000){
    pick <- sample(nrow(fst_dists_t),size=nrow(fst_dists_t),replace=TRUE)
    fst_dists_rep <- fst_dists_t[pick,]
    ibd_model_rep <- lm(scale_sim~dist,data=fst_dists_rep)
    summ_rep <- summary(ibd_model_rep)
    slopes[rep] <- summ_rep$coefficients[2,1]
  }
  l_boot <- quantile(slopes,probs=0.025)
  u_boot <- quantile(slopes,probs=0.975)
  
  ## pivot slopes CI
  l_pivot <- 2*slope - u_boot
  u_pivot <- 2*slope - l_boot
  
  ## build physical and genetic distance matrices for mantel test
  if(t==1){
    dist_km <- matrix(nrow=length(site_list),ncol=length(site_list))
    rownames(dist_km)=site_list
    colnames(dist_km)=site_list
    
    dist_fst_emp <- matrix(nrow=length(site_list),ncol=length(site_list))
    rownames(dist_fst_emp)=site_list
    colnames(dist_fst_emp)=site_list
    }
  dist_fst <- matrix(nrow=length(site_list),ncol=length(site_list))
  rownames(dist_fst)=site_list
  colnames(dist_fst)=site_list
  
  for(r in 2:length(site_list)){
    for(c in 1:(r-1)){
      correct_row <- filter(fst_dists_t, (site1==site_list[r]|site2==site_list[r]) & (site1==site_list[c]|site2==site_list[c]))
      if(t==1) {
        dist_km[r,c]=correct_row$dist
        dist_fst_emp[r,c]=correct_row$scale_emp
      }
      dist_fst[r,c]=correct_row$scale_sim
    } #c
  } #r
  dist_fst <- as.dist(dist_fst)
  if(t==1) {
    dist_km <- as.dist(dist_km)
    dist_fst_emp <- as.dist(dist_fst_emp)}
  
  ## do a mantel test to get IBD significance
  mant <- mantel.rtest(dist_fst,dist_km, nrepet=999)
  p_val <- mant$pval
  r_val <- mant$obs

  ## store it all  
  ibd_slopes_sim[t,] <- c(ticks[t],slope,se,r2,l_param,u_param,l_boot,u_boot,l_pivot,u_pivot,p_val,r_val)
} #t

##############################################
## get empirical IBD slope, with confidence intervals (bootstrap and parametric) and significance (mantel test)
##############################################
## empirical ibd model
ibd_model_emp <- lm(scale_emp~dist,data=fst_summary_dists)
summ_emp <- summary(ibd_model_emp)
slope_emp <- summ_emp$coefficients[2,1]
se_emp <- summ_emp$coefficients[2,2]
mant_emp <- mantel.rtest(dist_fst_emp,dist_km,nrepet=999) # mantel test for significance

## parametric slope CI
l_param_emp <- slope_emp-t_star*se_emp
u_param_emp <- slope_emp+t_star*se_emp

## boostrap slope CI
slopes_emp=vector()
for(rep in 1:1000){
  pick <- sample(nrow(fst_summary_dists),size=nrow(fst_summary_dists),replace=TRUE)
  fst_dists_rep <- fst_summary_dists[pick,]
  ibd_model_rep <- lm(scale_emp~dist,data=fst_dists_rep)
  summ_rep <- summary(ibd_model_rep)
  slopes_emp[rep] <- summ_rep$coefficients[2,1]
}
l_boot_emp <- quantile(slopes_emp,probs=0.025)
u_boot_emp <- quantile(slopes_emp,probs=0.975)

l_pivot_emp <- 2*slope_emp - u_boot_emp
u_pivot_emp <- 2*slope_emp - l_boot_emp

##############################################
## check overlap
##############################################
ibd_slopes_sim <- ibd_slopes_sim %>%
  mutate(overlap_boot=l_bootstrap<u_boot_emp)
```


```{r}
##############################################
## A couple of example IBD slope plots
##############################################

ggplot(filter(fst_dists,tick==2600),aes(x=dist,y=scale_emp))+
  geom_point()+
  ylim(-0.006,0.015)+
  geom_smooth(method='lm', se=FALSE)+
  annotate("text",x=190,y=0.013,label = paste0("slope = ",signif(slope_emp,3),"  ",signif(t_star*se_emp,3),"\n",
                                               "R^2 = ",signif(summ_emp$adj.r.squared,2), "\n",
                                               "Mantel p = ", signif(mant_emp$pvalue,3), "\n",
                                               "Mantel r = ", signif(mant_emp$obs,3)),
           hjust=1)+
  labs(title='Empirical IBD')

t=1
ggplot(filter(fst_dists,tick==ticks[t]),aes(x=dist,y=scale_sim))+
  geom_point()+
  ylim(-0.006,0.015)+
  geom_smooth(method='lm', se=FALSE)+
  annotate("text",x=190,y=0.013,label = paste0("slope = ",signif(ibd_slopes_sim$ibd_slope[t],3),"  ",signif(t_star*ibd_slopes_sim$slope_se[t],3),"\n",
                                               "R^2 = ",signif(ibd_slopes_sim$ibd_r2,2)[t], "\n",
                                               "Mantel p = ", signif(ibd_slopes_sim$mantel_p[t],3), "\n",
                                               "Mantel r = ", signif(ibd_slopes_sim$mantel_r[t],3)),
           hjust=1)+
  labs(title=paste0('Simulated IBD, t = ',ticks[t]))

t=8
ggplot(filter(fst_dists,tick==ticks[t]),aes(x=dist,y=scale_sim))+
  geom_point()+
  ylim(-0.006,0.015)+
  geom_smooth(method='lm', se=FALSE)+
  annotate("text",x=190,y=0.013,label = paste0("slope = ",signif(ibd_slopes_sim$ibd_slope[t],3),"  ",signif(t_star*ibd_slopes_sim$slope_se[t],3),"\n",
                                               "R^2 = ",signif(ibd_slopes_sim$ibd_r2,2)[t], "\n",
                                               "Mantel p = ", signif(ibd_slopes_sim$mantel_p[t],3), "\n",
                                               "Mantel r = ", signif(ibd_slopes_sim$mantel_r[t],3)),
           hjust=1)+
  labs(title=paste0('Simulated IBD, t = ',ticks[t]))
```

```{r}
##############################################
## plot empirical and simulated IBD slopes
##############################################

ggplot()+
  geom_histogram(data=as.data.frame(ibd_slopes_sim),aes(x=ibd_slope),bins=15)+
  geom_vline(aes(xintercept=c(l_boot_emp, slope_emp, u_boot_emp), color='empirical value', lty=(c('CI (bootstrap)','mean','CI (bootstrap)'))),lwd=1)+
#  labs(title=paste0('Distribution of IBD slope over simulated timesteps (empirical value mean +/- se in red)\n Simulated value within 1se of empirical: ',round(within_emp_se,2),'\n Empirical value within 1se of simulated: ',round(mean(ibd_slopes_sim$emp_in),2)))+
  labs(title=paste0('Distribution of IBD slope over simulated timesteps\nSimulated and empirical CIs overlap: ',round(mean(ibd_slopes_sim$overlap_boot),2)))+
  theme(legend.position="none")
  #coord_flip()

ggplot(ibd_slopes_sim,aes(x=tick))+
  geom_point(aes(y=ibd_slope,color='simulated'))+
  geom_line(aes(y=ibd_slope,color='simulated'),alpha=0.5)+
  #geom_errorbar(aes(ymin=l_parametric,ymax=u_parametric,color='param'))+
  geom_errorbar(aes(ymin=l_bootstrap,ymax=u_bootstrap,color='simulated'))+
  #geom_errorbar(aes(ymin=l_pivot,ymax=u_pivot,color='pivot'))+
  geom_hline(aes(yintercept=slope_emp,color='empirical'),lty='solid')+
  geom_hline(aes(yintercept=l_boot_emp,color='empirical'),lty='dashed')+
  geom_hline(aes(yintercept=u_boot_emp,color='empirical'),lty='dashed')

```

## Analyses from D'Aloia et al 2020

```{r}
library(adegenet)
library(vcfR)
library(dartR)
library(snpStats)

treefile <- "full_pop_run/VCFs/A1/ts_9143221642690466364_t009600"
inds <- read_csv(paste0(treefile,".csv"),col_names=F,show_col_types=FALSE)
inds <- as.data.frame(t(inds))
inds <- separate_wider_delim(inds,cols=V1,delim=',',names=c('flags','x','y','zero','parents','array','dtype','pedID','pedp1','pedp2','age','subpop','sex','flags2')) %>%
  dplyr::select(x,y,pedID,pedp1,pedp2,age,sex)

inds <- mutate(inds,x = as.numeric(gsub("[^0-9.]","",x))) %>%
  mutate(y = as.numeric(gsub("[^0-9.]","",y))) %>%
  mutate(pedID = as.factor(gsub("[^0-9.]","",pedID))) %>%
  mutate(pedp1 = str_sub(gsub("\\D","",pedp1),start=2)) %>%
  mutate(pedp2 = str_sub(gsub("\\D","",pedp2),start=2)) %>%
  mutate(age = as.numeric(gsub("\\D","",age))) %>%
  mutate(sex = as.numeric(gsub("\\D","",sex))) %>%
  mutate(id=0:(nrow(inds)-1))

sites <- read_csv(paste0(treefile,"_sites.csv"),col_names=F)
sites <- as.data.frame(t(sites))
colnames(sites) = c('pedID','site_member')
sites <- mutate(sites,pedID=as.factor(pedID))

# make a column in inds so that ids exactly match the vcf
inds <- mutate(inds,gt_name=paste0("tsk_",id))
inds <- left_join(inds,sites,by="pedID")

sample_sites <- read_csv('../data/sgs_sites_SLiM.csv',show_col_types=FALSE)
sitenames <- data.frame(site_name = sample_sites$Site, site_member = as.factor(1:nrow(sample_sites)))
inds$site_member <- as.factor(inds$site_member)
inds <- left_join(inds,sitenames,by="site_member")

# create a factor of the sampling site of each individual in vcf
ind_sites <- as.factor(arrange(inds,id)$site_name)
ind_sites <- as.factor(substr(ind_sites,1,1))


simVCF <- read.vcfR(paste0(treefile,".vcf"),verbose=FALSE)
simGI <- vcfR2genind(simVCF)
simGI@pop <- ind_sites
simGL <- gi2gl(simGI,verbose=0)

#############################################################################
# Filter: LD and rare alleles
#############################################################################

# LD:
simGL@pop <- as.factor(rep('pop1',length(simGL@ind.names))) #remove site info temporarily
ld_report <- gl.report.ld.map(simGL,maf=0.02, plot.out=FALSE)
simGL <- gl.filter.ld(simGL,ld_report, threshold=0.8, verbose=3) # R^2>0.8 is what was used in the paper
simGL@pop <- ind_sites #restore site info

# rare alleles
simGL <- gl.filter.maf(simGL,threshold=0.02, plot.out=FALSE, verbose=3) # also removes monomorphic loci
#save(simGL, file="genlight_test.RData")
#############################################################################
# Calculate pairwise fsts
#############################################################################
# do FST just to check if it's working. Answer: yes. I get exactly the same FST matrix here as I did when I analyzed the data the first time. So the right site is associated with each individual, etc.
#fsts <- gl.fst.pop(simGL,nboots=1, verbose=3)
```



```{r}
load("genlight_test.RData")
grp_11 <- find.clusters(simGL, max.n.clust = 20, n.pca=1300, n.clust=11)

save(grp_4,grp_6,grp_7,grp_11,grp_12,file="test_grps.RData")
load("test_grps.RData")

grp <- grp_6

table(pop(simGL),grp$grp) # this isn't working very well; doesn't look like there's any connection between an individual's site and what cluster it ends up in. Did I mess something up in the data-processing? Checked by running the FST matrix, and it looks exactly the same. So no problem there. 

dapc_6_disc_2 <- dapc(simGL, grp$grp, n.pca=200, n.da=2)

save(dapc_4, dapc_6_disc_2, dapc_6_disc_6, dapc_12_disc_2, dapc_12_disc_5, file="test_dapcs.RData")
load("test_dapcs.RData")


dapc1 <- dapc_4
plotting_data <- as.data.frame(dapc1$ind.coord)
plotting_data$pop <- simGL@pop
ggplot(plotting_data,aes(x=LD1,y=LD2,color=pop))+
    geom_point()

scatter(dapc1)

table(pop(simGL),dapc1$assign)


```

## Here's the empirical SNP data
(It's not in a format I can immediately use. VCF-ish, but without the metadata and some of the intro columns.)
```{r}
goby <- read.csv("goby_genotypes_SNP.txt", sep="\t", skip=1)

```


