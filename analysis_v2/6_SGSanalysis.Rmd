---
title: "Untitled"
author: "Your Name Here"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse); theme_set(theme_bw())
library(ggpattern)
library(lme4)
library(broom.mixed)
library(Matrix)
library(MuMIn)
library(colorspace)
```

## Load and process data
```{r, eval=FALSE}
########## Process empirical FSTs (only need to do this once)

fst_emp <- read.csv('../data/FST_empirical.csv',header=T)
fst_emp_long <- pivot_longer(fst_emp,cols=2:ncol(fst_emp),names_to=c('site2'))
fst_emp_long$sites <- NA
for(i in 1:nrow(fst_emp_long)){
  fst_emp_long$sites[i] <- paste(sort(as.matrix(fst_emp_long[i,1:2])),collapse='.')
}
fst_emp_long <- filter(fst_emp_long,!is.na(value)) %>%
  rename(emp_fst=value)
fst_emp <- dplyr::select(fst_emp_long,sites,fst=emp_fst) 
rm(fst_emp_long)

save(fst_emp, file='../data/FST_emp.RData')

```

```{r, eval=FALSE}
########## Process data into a format to use in the analyses in this file
n_run=1

## load data
load(file='../data/FST_emp.RData') # empirical FSTs
sample_sites <- read_csv('../data/sgs_sites_SLiM.csv',show_col_types=FALSE) #info on sample sites
fst_folder_path <- paste0('C:/Users/eschlatter/Dropbox/DispersalSGS/analysis_v2/full_pop_run/A',n_run)
load(file=paste0(fst_folder_path,"/FST_all.RData")) #sequence of simulated FST data

## add pop1 and pop2 columns
fst_all_sim <- mutate(fst_all_sim,pop1=substr(sites,1,1)) %>%
  mutate(pop2=substr(sub('.*\\.','',sites),1,1)) %>%
  mutate(pop1=case_match(pop1,'T'~'B', .default=pop1),pop2=case_match(pop2,'T'~'B', .default=pop2)) # Turneffe clusters with the barrier

## add region1 and region2 columns
fst_all_sim <- dplyr::select(fst_all_sim,tick,fst,sites,site1,site2,pop1,pop2) %>%
  left_join(dplyr::select(sample_sites,Site, region1=Region),by=c('site1'='Site')) %>%
  left_join(dplyr::select(sample_sites,Site, region2=Region),by=c('site2'='Site')) %>%
  mutate(region1=case_match(region1,
                            'barrier (northern)'~'N','barrier (central)'~'C',
                            'Turneffe Atoll'~'T', .default=NA)) %>%
  mutate(region2=case_match(region2,
                            'barrier (northern)'~'N','barrier (central)'~'C',
                            'Turneffe Atoll'~'T', .default=NA)) 

## add both_pops column (in alphabetical order, so we don't have e.g. BG and GB)
fst_all_sim$both_pops <- NA
for(j in 1:nrow(fst_all_sim)){
  fst_all_sim$both_pops[j] <- paste0(sort(as.matrix(fst_all_sim[j,c('pop1','pop2')])), collapse='')
}

## add both_regions column (also in alphabetical order)
fst_all_sim$both_regions <- NA
for(j in 1:nrow(fst_all_sim)){
  if(!is.na(fst_all_sim$region1[j]) & !is.na(fst_all_sim$region2[j])){
    fst_all_sim$both_regions[j] <- paste(sort(as.matrix(fst_all_sim[j,c('region1','region2')])), collapse='')
  }
}

## make a new dataframe that summarizes across ticks
fst_summary <- filter(fst_all_sim, tick>2500) %>% # remove the pre-equilibrium values! Important!
  group_by(sites) %>%
  summarize(median=median(fst), mean=mean(fst), sd = sd(fst), q95_low=quantile(fst,0.025),
            q95_up=quantile(fst,0.975),both_pops=first(both_pops),both_regions=first(both_regions)) %>%
  left_join(fst_emp,by='sites') %>%
  rename(fst_emp=fst) %>%
  filter(!is.na(fst_emp))

save(fst_all_sim,fst_summary,file=paste0("full_pop_run/fst_data_for_analysis_A",n_run,".RData"))
```

```{r}
n_run=1
load(paste0("full_pop_run/fst_data_for_analysis_A",n_run,".RData"))
load(file='../data/FST_emp.RData') # empirical FSTs
```


## Dynamics

```{r}
all_by_tick <- group_by(fst_all_sim,tick) %>% summarize(mean_fst=mean(fst))
group_by(fst_all_sim,tick,both_pops) %>%
  summarize(pop_fst=mean(fst)) %>%
  ggplot(aes(x=tick,y=pop_fst,color=both_pops))+
  geom_line()+
  geom_line(data=all_by_tick,aes(x=tick,y=mean_fst),color='black')

group_by(fst_all_sim,tick,both_pops) %>%
  summarize(pop_fst=mean(fst)) %>%
  ggplot(aes(x=tick,y=pop_fst,color=both_pops))+
  geom_line()+
  geom_hline(aes(yintercept=0))+
  facet_wrap(vars(both_pops), scales="free")#+
  geom_smooth(method='lm',se=FALSE)
  
ggplot(data=all_by_tick,aes(x=tick,y=mean_fst))+
  geom_line()+
  geom_point()

```


## Linear model of observed vs predicted site-pair FSTs
To think about using the values over time, take a look at: https://bbolker.github.io/mixedmodels-misc/notes/corr_braindump.html

For now, I'm just using the mean value (simulated over time) for each site pair as the predictor. Accounting for nonindependence b/c of reuse of sites using a multiple membership (i.e., cross-classified) model.
```{r}
fst_data <- left_join(fst_summary, fst_emp,by='sites') %>%
  dplyr::select(sites,x=mean,y=fst) %>%
  mutate(site1=str_split_i(sites,"\\.",1)) %>%
  mutate(site2=str_split_i(sites,"\\.",2))

site_list <- unique(c(fst_data$site1,fst_data$site2))

## make model matrix W
W = matrix(nrow=nrow(fst_data),ncol=length(site_list))
colnames(W) = site_list
rownames(W) = fst_data$sites
for(i in 1:nrow(W)){
  for(j in 1:ncol(W)){
    W[i,j] = ifelse((site_list[j] == fst_data$site1[i]) | (site_list[j] == fst_data$site2[i]), 1, 0)
  } # j (sites)
} # i (site pairs) 
```

Code from https://bbolker.github.io/mixedmodels-misc/notes/multimember.html:
```{r modular_fit}
## helpful to specify a factor with the right levels:
## actual values are unimportant since we will specify Zt/Ztlist directly
fst_data$fake <- rep(site_list,length.out=nrow(fst_data)) ## make a dummy column with the right item names
lmod <- lFormula(y~x+(1|fake), data=fst_data) ## create the model
lmod$reTrms$Zt <- lmod$reTrms$Ztlist[[1]] <- Matrix(t(W))  ## give the actual model matrix Zt to the model
devfun <- do.call(mkLmerDevfun, lmod) ## makes a deviance function
opt <- optimizeLmer(devfun) ## takes a deviance function and optimizes over theta
m1 <- mkMerMod(environment(devfun), opt, lmod$reTrms, fr = lmod$fr) ## produces a lmerMod object from previous steps

summary(m1)
```
```{r plotresults}
dd <- tidy(m1, effects="ran_vals")
dd <- transform(dd, level=reorder(level,estimate))
ggplot(dd,aes(x=level,y=estimate))+
    geom_pointrange(aes(ymin=estimate-2*std.error,
              ymax=estimate+2*std.error))+coord_flip()
```
### Variance explained: 
Why can't we just use "regular R^2"? It doesn't account for the random effects. Lots of options, including:

#### Nakagawa and Schielzeth's pseudo-R^2
I think I'll go with this, since it's easily citable. 
Marginal and conditional pseudo-R^2 for GLMMs from Nakagawa and Schielzeth 2012: https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/j.2041-210x.2012.00261.x

Here are the values we get:
```{r}
r2 <- r.squaredGLMM(m1)
r2
```

##### More info:
marginal = fixed effects (here, SLiM simulation value) only
conditional = entire model, including fixed and random (here, site ID) effects

$$
R^2_m = \frac{\sigma^2_f}{\sigma^2_f+\sigma^2_\alpha+\sigma^2_\epsilon} \\

R^2_c = \frac{\sigma^2_f+\sigma^2_\alpha}{\sigma^2_f+\sigma^2_\alpha+\sigma^2_\epsilon}

$$
where $\sigma^2_f$ = variance of fixed effect components
$\sigma^2_\alpha$ = variance of random effects
$\sigma^2_\epsilon$ = "observation-level" variance

They recommend presenting both marginal and conditional in publications. I think conditional is the most relevant here, because we know the site-level info, and want to do the best job we can at relating SLiM values to empirical values. 




#### Quick idea from Bolker
Bolker has a discussion of this issue: https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html#how-do-i-compute-a-coefficient-of-determination-r2-or-an-analogue-for-glmms

One idea he suggests is the squared correlation between the response variable (here, empirical FST) and the predicted values (here, the output from the statistical model, given the SLiM value and the site memberships):
```{r}
df_plot <- data.frame(resp=model.response(model.frame(m1)),
                      pred=predict(m1,type="response"))

var_expl <- (cor(df_plot$resp,df_plot$pred))^2
var_expl

ggplot(data=df_plot,aes(x=pred,y=resp))+
  geom_point()+
  labs(x="model prediction",y="empirical value")+
  annotate("text",x = 0, y = 0.0275, label = paste("variance explained: \n",round(var_expl,3)))+
  theme_minimal()
```

###Variance explained against a 1-1 line: (https://www.css.cornell.edu/faculty/dgr2/_static/files/R_html/ModelEvaluation.html)
Also think about out-of-sample prediction?
```{r}
numerator <- sum((df_plot$resp-df_plot$pred)^2)
denominator <- sum((df_plot$resp-mean(df_plot$resp))^2)
r2 <- 1-numerator/denominator
```


## Predicted vs observed FST: analysis ideas

### Pete's idea
Average over sites within the same population. 

```{r}
fst_sim_bypop <- left_join(fst_all_sim, fst_emp, by='sites') %>%
  rename(fst_sim=fst.x, fst_emp=fst.y) %>%
  filter(!is.na(fst_emp), tick>=2500) %>%
  group_by(both_pops, tick) %>%
  summarize(sim_pops_mean=mean(fst_sim), sim_pops_sd = sd(fst_sim), sim_q025 = quantile(fst_sim,0.025), sim_q975=quantile(fst_sim,0.975),
            emp_pops_mean=mean(fst_emp), emp_pops_sd = sd(fst_emp), emp_q025 = quantile(fst_emp,0.025), emp_q975=quantile(fst_emp,0.975))
  
#sds
ggplot(fst_sim_bypop,aes(x=tick,y=sim_pops_mean, color=both_pops))+
  geom_point()+
  geom_line()+
  geom_hline(aes(yintercept=emp_pops_mean))+
  geom_hline(aes(yintercept=emp_pops_mean-emp_pops_sd),lty='dashed')+
  geom_hline(aes(yintercept=emp_pops_mean+emp_pops_sd),lty='dashed')+
  geom_errorbar(aes(ymin=sim_pops_mean-sim_pops_sd, ymax=sim_pops_mean+sim_pops_sd, color=both_pops))+
  facet_wrap(vars(both_pops), scales='free')

# 95% quantiles
ggplot(fst_sim_bypop,aes(x=tick,y=sim_pops_mean, color=both_pops))+
  geom_point()+
  geom_line()+
  geom_hline(aes(yintercept=emp_pops_mean))+
  geom_hline(aes(yintercept=emp_q025),lty='dashed')+
  geom_hline(aes(yintercept=emp_q975),lty='dashed')+
  geom_errorbar(aes(ymin=sim_q025, ymax=sim_q975, color=both_pops))+
  facet_wrap(vars(both_pops), scales='free')
```

### Residuals

#### Broad-scale

```{r}
fst_rmse <- left_join(fst_all_sim, fst_emp, by='sites') %>%
  rename(fst_sim=fst.x, fst_emp=fst.y) %>%
  filter(!is.na(fst_emp), tick>=2500) %>%
  group_by(tick,both_pops) %>%
  summarize(dev=median(fst_emp-fst_sim), dev_q025=quantile(fst_emp-fst_sim,0.025),dev_q975=quantile(fst_emp-fst_sim, 0.975))

ggplot(fst_rmse,aes(x=tick,y=dev,color=both_pops))+
  geom_point()+
  geom_errorbar(aes(ymin=dev_q025,ymax=dev_q975,color=both_pops))+
  ylab('fst_emp-fst_sim (median and 95% quantiles)')+
  geom_line()+
  geom_hline(aes(yintercept=0))+
  facet_wrap(vars(both_pops))
```


```{r}
all_fst <- left_join(fst_all_sim, fst_emp, by='sites') %>%
  rename(fst_sim=fst.x, fst_emp=fst.y) %>%
  filter(!is.na(fst_emp), tick>=2500) %>%
  mutate(resid=fst_emp-fst_sim)

# I don't like this one, because it treats points within the same pop group as equally related, no matter what site pair or tick they belong to
ggplot(all_fst,aes(x=both_pops,y=resid, fill=both_pops))+
  geom_violin()+
  geom_hline(aes(yintercept=0))

# this takes the median within each pop group at each tick, and plots the distribution of medians over all ticks. so the distributions are more restricted, and we don't get any sense of spread within the pop group.
all_fst %>% group_by(both_pops,tick) %>%
  summarize(resid_med=median(resid),resid_q025=quantile(resid,0.025),resid_q975=quantile(resid,0.975)) %>%
  ggplot(aes(x=both_pops,y=resid_med, fill=both_pops))+
  geom_violin()+
  geom_hline(aes(yintercept=0))
```


```{r}
# this model doesn't control for nonindependence among data points by shared sites. s.e.'s are much tighter. Using the one that follows is better.
fst_rmse_formodel <- left_join(fst_all_sim, fst_emp, by='sites') %>%
  rename(fst_sim=fst.x, fst_emp=fst.y) %>%
  filter(!is.na(fst_emp), tick>=2500) %>%
  mutate(dev=fst_emp-fst_sim)

dev_model <- lm(dev~both_pops+tick, data=fst_rmse_formodel)
dev_model

coefs <- as.data.frame(summary(dev_model)$coefficients) %>%
  mutate(var=c('BB','BG','BL','GG','GL','LL','tick'))
colnames(coefs) <- c('Estimate','se','t','p','var')

ggplot(coefs,aes(x=var,y=Estimate, color=var))+
  geom_point()+
  geom_errorbar(aes(ymin=Estimate-se,ymax=Estimate+se))+
  geom_hline(aes(yintercept=0))
```


```{r}
fst_resid_data <- left_join(fst_all_sim, fst_emp, by='sites') %>%
  rename(fst_sim=fst.x, fst_emp=fst.y) %>%
  filter(!is.na(fst_emp), tick>=2500) %>%
  mutate(resid=fst_emp-fst_sim)
site_list <- unique(c(fst_resid_data$site1,fst_resid_data$site2))

## make model matrix W
W = matrix(nrow=nrow(fst_resid_data),ncol=length(site_list))
colnames(W) = site_list
rownames(W) = fst_resid_data$sites
for(i in 1:nrow(W)){
  for(j in 1:ncol(W)){
    W[i,j] = ifelse((site_list[j] == fst_resid_data$site1[i]) | (site_list[j] == fst_resid_data$site2[i]), 1, 0)
  } # j (sites)
} # i (site pairs) 

fst_resid_data$sitenames <- rep(site_list,length.out=nrow(fst_resid_data)) ## make a dummy column with the right item names
lmod <- lFormula(resid~both_pops+(1|sitenames), data=fst_resid_data) ## create the model
lmod$reTrms$Zt <- lmod$reTrms$Ztlist[[1]] <- Matrix(t(W))  ## give the actual model matrix Zt to the model
devfun <- do.call(mkLmerDevfun, lmod) ## makes a deviance function
opt <- optimizeLmer(devfun) ## takes a deviance function and optimizes over theta
m1 <- mkMerMod(environment(devfun), opt, lmod$reTrms, fr = lmod$fr) ## produces a lmerMod object from previous steps

m1
a <- summary(m1)

summary(m1)$coefficients

coefs <- as.data.frame(summary(m1)$coefficients) %>%
  mutate(var=c('BB','BG','BL','GG','GL','LL'))
colnames(coefs) <- c('Estimate','se','t','var')

ggplot(coefs,aes(y=var,x=Estimate, color=var))+
  geom_point()+
  geom_linerange(aes(xmin=Estimate-se,xmax=Estimate+se), lwd=1.2)+
  geom_vline(aes(xintercept=0))+
  xlab('Estimate +/- s.e.')+
  ylab('Population pair')+
  scale_y_discrete(limits=rev)+
  theme_minimal()+
  theme(legend.position="none")
```

#### Broad-scale, separate Turneffe

```{r}
fst_dev_turneffe <- left_join(fst_all_sim, fst_emp, by='sites') %>%
  rename(fst_sim=fst.x, fst_emp=fst.y) %>%
  filter(!is.na(fst_emp), tick>=2500) %>%
  mutate(pop1.T=case_match(region1,"T"~"T","N"~"B","C"~"B",.default=pop1)) %>%
  mutate(pop2.T=case_match(region2,"T"~"T","N"~"B","C"~"B",.default=pop2))
  

fst_rmse <- left_join(fst_all_sim, fst_emp, by='sites') %>%
  rename(fst_sim=fst.x, fst_emp=fst.y) %>%
  filter(!is.na(fst_emp), tick>=2500) %>%
  group_by(tick,both_pops) %>%
  summarize(dev=median(fst_emp-fst_sim), dev_q025=quantile(fst_emp-fst_sim,0.025),dev_q975=quantile(fst_emp-fst_sim, 0.975))

ggplot(fst_rmse,aes(x=tick,y=dev,color=both_pops))+
  geom_point()+
  geom_errorbar(aes(ymin=dev_q025,ymax=dev_q975,color=both_pops))+
  ylab('fst_emp-fst_sim (median and 95% quantiles)')+
  geom_line()+
  geom_hline(aes(yintercept=0))+
  facet_wrap(vars(both_pops))
```

#### Fine-scale

```{r}

cols_fine <- c("NN"="#01665e", "CC"="#5ab4ac", "TT"="#8c510a", "CN"="#c7eae5", "NT"="#d8b365",  "CT"="#f6e8c3")

fst_dev_fine <- left_join(fst_all_sim, fst_emp, by='sites') %>%
  rename(fst_sim=fst.x, fst_emp=fst.y) %>%
  filter(!is.na(fst_emp), tick>=2500, !is.na(both_regions)) %>%
  group_by(tick,both_regions) %>%
  summarize(dev=median(fst_emp-fst_sim), dev_q025=quantile(fst_emp-fst_sim,0.025),dev_q975=quantile(fst_emp-fst_sim, 0.975))

ggplot(fst_dev_fine,aes(x=tick,y=dev,color=both_regions))+
  geom_point()+
  geom_errorbar(aes(ymin=dev_q025,ymax=dev_q975,color=both_regions))+
  scale_color_discrete_qualitative(palette="Harmonic")+
  ylab('fst_emp-fst_sim (median and 95% quantiles)')+
  geom_line()+
  geom_hline(aes(yintercept=0))+
  facet_wrap(vars(both_regions))
```
```{r}
fst_resid_data_fine <- filter(fst_resid_data, !is.na(both_regions))
site_list <- unique(c(fst_resid_data_fine$site1,fst_resid_data_fine$site2))

## make model matrix W
W = matrix(nrow=nrow(fst_resid_data_fine),ncol=length(site_list))
colnames(W) = site_list
rownames(W) = fst_resid_data_fine$sites
for(i in 1:nrow(W)){
  for(j in 1:ncol(W)){
    W[i,j] = ifelse((site_list[j] == fst_resid_data_fine$site1[i]) | (site_list[j] == fst_resid_data_fine$site2[i]), 1, 0)
  } # j (sites)
} # i (site pairs) 

fst_resid_data_fine$sitenames <- rep(site_list,length.out=nrow(fst_resid_data_fine)) ## make a dummy column with the right item names
lmod <- lFormula(resid~both_regions+(1|sitenames), data=fst_resid_data_fine) ## create the model
lmod$reTrms$Zt <- lmod$reTrms$Ztlist[[1]] <- Matrix(t(W))  ## give the actual model matrix Zt to the model
devfun <- do.call(mkLmerDevfun, lmod) ## makes a deviance function
opt <- optimizeLmer(devfun) ## takes a deviance function and optimizes over theta
m1 <- mkMerMod(environment(devfun), opt, lmod$reTrms, fr = lmod$fr) ## produces a lmerMod object from previous steps

m1
a <- summary(m1)

summary(m1)$coefficients

coefs <- as.data.frame(summary(m1)$coefficients) %>%
  mutate(var=c('CC','CN','CT','NN','NT','TT'))
colnames(coefs) <- c('Estimate','se','t','var')

ggplot(coefs,aes(y=var,x=Estimate, color=var))+
  geom_point()+
  geom_linerange(aes(xmin=Estimate-se,xmax=Estimate+se), lwd=1.2)+
  scale_color_discrete_qualitative(palette="Harmonic")+
  geom_vline(aes(xintercept=0))+
  xlab('Estimate +/- s.e.')+
  ylab('Region pair')+
  scale_y_discrete(limits=rev)+
  theme_minimal()+
  theme(legend.position="none")
```



## Predicted vs observed FST plots

### Broad-scale
```{r}
ggplot(fst_summary,aes(x=fst_emp,y=mean))+
  geom_errorbar(aes(ymin=mean-sd,ymax=mean+sd, color=both_pops),position = position_jitter(seed = 100), alpha=0.15)+
  geom_point(aes(color=both_pops), position = position_jitter(seed = 100))+
  geom_abline(aes(slope=1,intercept=0))+
  theme_minimal()+
  xlim(c(-0.005, 0.032))+
  ylim(c(-0.005, 0.032))+
  labs(x = "empirical FST", y="simulated FST (mean+/-sd over 7500 generations)")+
  coord_flip()
```
### Fine-scale
```{r}
ggplot(filter(fst_summary,both_regions %in% c('NN','CC','TT','CN','NT','CT')),aes(x=fst_emp,y=mean))+
  geom_errorbar(aes(ymin=mean-sd,ymax=mean+sd, color=both_regions),position = position_jitter(seed = 100), alpha=0.15)+
  geom_point(aes(color=both_regions, shape=both_regions), position = position_jitter(seed = 100))+
  scale_color_discrete_qualitative(palette="Harmonic")+
  geom_abline(aes(slope=1,intercept=0))+
  theme_minimal()+
  labs(x = "empirical FST", y="simulated FST (mean+/-sd over 7500 generations)")+
  coord_flip()
```
## Density plots

### Broad-scale
```{r}
fst_summary$both_pops <- factor(fst_summary$both_pops,levels=c('BB','GG','LL','BG','BL','GL'))

ggplot(data=fst_summary,aes(x=median,fill=both_pops,pattern_fill=both_pops,pattern_density=both_pops))+
  geom_density_pattern(pattern_spacing=0.03,alpha=0.6,pattern_alpha=0.6)+
  scale_pattern_density_manual(values=c(0,0,0,0.5,0.5,0.5),name='Populations')+
  scale_fill_manual(values=c('#91bfdb','#fc8d59','#ffffbf','#91bfdb','#91bfdb','#fc8d59'),name='Populations')+
  scale_pattern_fill_manual(values=c('#91bfdb','#fc8d59','#ffffbf','#fc8d59','#ffffbf','#ffffbf'),name='Populations')+
  theme_bw()+
  #theme(legend.position='bottom')+
  labs(x="Simulated FST")+
  xlim(c(0,0.035))+
  #ylim(c(0,2000))+
  guides(pattern_density = guide_legend(nrow = 3))

ggplot(data=fst_summary,aes(x=fst_emp,fill=both_pops,pattern_fill=both_pops,pattern_density=both_pops))+
  geom_density_pattern(pattern_spacing=0.03,alpha=0.6,pattern_alpha=0.6)+
  scale_pattern_density_manual(values=c(0,0,0,0.5,0.5,0.5),name='Populations')+
  scale_fill_manual(values=c('#91bfdb','#fc8d59','#ffffbf','#91bfdb','#91bfdb','#fc8d59'),name='Populations')+
  scale_pattern_fill_manual(values=c('#91bfdb','#fc8d59','#ffffbf','#fc8d59','#ffffbf','#ffffbf'),name='Populations')+
  theme_bw()+
  #theme(legend.position='bottom')+
  labs(x='Empirical FST')+
  ylim(c(0,2000))+
  xlim(c(0,0.035))+
  guides(pattern_density = guide_legend(nrow = 3))

ggplot(data=fst_summary,aes(x=median - fst_emp,fill=both_pops,pattern_fill=both_pops,pattern_density=both_pops))+
  geom_density_pattern(pattern_spacing=0.03,alpha=0.6,pattern_alpha=0.6)+
  scale_pattern_density_manual(values=c(0,0,0,0.5,0.5,0.5),name='Populations')+
  scale_fill_manual(values=c('#91bfdb','#fc8d59','#ffffbf','#91bfdb','#91bfdb','#fc8d59'),name='Populations')+
  scale_pattern_fill_manual(values=c('#91bfdb','#fc8d59','#ffffbf','#fc8d59','#ffffbf','#ffffbf'),name='Populations')+
  theme_bw()+
  #theme(legend.position='bottom')+
  labs(x='Simulated minus empirical FST')+
  guides(pattern_density = guide_legend(nrow = 3))

```


### Fine-scale
```{r}
fst_summary_sub <- filter(fst_summary,!is.na(both_regions)) %>%
  mutate(both_regions=factor(both_regions,levels=c('NN','CC','TT','CN','CT','NT')))

ggplot(data=fst_summary_sub,aes(x=median,fill=both_regions,pattern_fill=both_regions,pattern_density=both_regions))+
  geom_density_pattern(pattern_spacing=0.02,alpha=0.5,pattern_alpha=0.5)+
  scale_pattern_density_manual(values=c(0,0,0,0.5,0.5,0.5),name='Regions')+
  scale_fill_manual(values=c('#2b8cbe','#a6bddb','#ece7f2','#2b8cbe','#2b8cbe','#a6bddb'),name='Regions')+
  scale_pattern_fill_manual(values=c('#2b8cbe','#a6bddb','#ece7f2','#a6bddb','#ece7f2','#ece7f2'),name='Regions')+
  theme_bw()+
  #ylim(0,1000)+
  labs(x="Simulated FST")+
  guides(pattern_density = guide_legend(nrow = 3))

ggplot(data=fst_summary_sub,aes(x=fst_emp,fill=both_regions,pattern_fill=both_regions,pattern_density=both_regions))+
  geom_density_pattern(bw=0.0005,pattern_spacing=0.02,alpha=0.6,pattern_alpha=0.6)+ # try bw=0.0005 to remove lumpiness
  scale_pattern_density_manual(values=c(0,0,0,0.5,0.5,0.5),name='Regions')+
  scale_fill_manual(values=c('#2b8cbe','#a6bddb','#ece7f2','#2b8cbe','#2b8cbe','#a6bddb'),name='Regions')+
  scale_pattern_fill_manual(values=c('#2b8cbe','#a6bddb','#ece7f2','#a6bddb','#ece7f2','#ece7f2'),name='Regions')+
  theme_bw()+
  ylim(0,1000)+
  labs(x='Empirical FST')+
  guides(pattern_density = guide_legend(nrow = 3))

ggplot(data=fst_summary_sub,aes(x=median - fst_emp,fill=both_regions,pattern_fill=both_regions,pattern_density=both_regions))+
  geom_density_pattern(bw=0.0005,pattern_spacing=0.02,alpha=0.6,pattern_alpha=0.6)+ # try bw=0.0005 to remove lumpiness
  scale_pattern_density_manual(values=c(0,0,0,0.5,0.5,0.5),name='Regions')+
  scale_fill_manual(values=c('#2b8cbe','#a6bddb','#ece7f2','#2b8cbe','#2b8cbe','#a6bddb'),name='Regions')+
  scale_pattern_fill_manual(values=c('#2b8cbe','#a6bddb','#ece7f2','#a6bddb','#ece7f2','#ece7f2'),name='Regions')+
  theme_bw()+
  ylim(0,1000)+
  labs(x='Simulated minus Empirical FST')+
  guides(pattern_density = guide_legend(nrow = 3))
```
## IBD plots
Our simulated IBD slope is higher than the empirical one. (This is using data from North and Central Barrier only.)

```{r}
load('../data/sitepair_dists.RData')

fst_summary_dists <- left_join(fst_summary,sitepair_dists,by = 'sites', keep=FALSE) %>%
  mutate(scale_emp = fst_emp/(1-fst_emp), scale_sim = mean/(1-mean)) %>%
  dplyr::select(sites,scale_emp,scale_sim,dist, both_pops,both_regions)

fst_dists <- left_join(filter(fst_all_sim,tick>2500),sitepair_dists,by = 'sites', keep=FALSE) %>%
  mutate(scale_sim = fst/(1-fst)) %>%
  dplyr::select(tick, sites,scale_sim,dist, both_pops,both_regions) %>%
  filter(!is.na(dist))

ibd_model_emp <- lm(scale_emp~dist,data=fst_summary_dists)
summ_emp <- summary(ibd_model_emp)
slope_emp <- summ_emp$coefficients[2,1]
se_emp <- summ_emp$coefficients[2,2]

ticks <- unique(fst_dists$tick)
ibd_slopes_sim <- data.frame(ibd_slope=numeric(), slope_se=numeric())
for(t in 1:length(ticks)){
  ibd_model_sim <- lm(scale_sim~dist,data=filter(fst_dists),tick==ticks[t] & both_regions%in%c('NN','CC','CN'))
  summ <- summary(ibd_model_sim)
  slope <- summ$coefficients[2,1]
  se <- summ$coefficients[2,2]
  ibd_slopes_sim[t,] <- c(slope,se)
}

ibd_slopes_sim <- mutate(ibd_slopes_sim,
                         emp_in = ((slope_emp > ibd_slope - slope_se) & (slope_emp < ibd_slope + slope_se)))

mean(ibd_slopes_sim$emp_in)


## barrier only (no Turneffe)
ggplot(filter(fst_summary_dists,both_regions%in%c('NN','CC','CN')),aes(x=dist,y=scale_emp))+
  geom_point(size=1.1)+
  theme_bw()+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(title='Empirical',x='distance (km)',y='FST/(1-FST)')+
  ylim(c(-0.002,0.008))+
  geom_smooth(method='lm',se=FALSE)

ggplot(filter(fst_summary_dists,both_regions%in%c('NN','CC','CN')),aes(x=dist,y=scale_sim))+
  geom_point(size=1.1)+
  theme_bw()+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(title='Simulated', x='distance (km)',y='FST/(1-FST)\n (mean over simulated timesteps)')+
  ylim(c(-0.002,0.008))+
  geom_smooth(method='lm',se=FALSE)

within_emp_se <- sum(ibd_slopes_sim$ibd_slope>(slope_emp-se_emp) & ibd_slopes_sim$ibd_slope<(slope_emp+se_emp))/nrow(ibd_slopes_sim)
ibd_slopes_sim <- mutate(ibd_slopes_sim,overlap = ( ibd_slope-slope_se < slope_emp+se_emp )) #note that this wouldn't catch cases where the two are nonoverlapping and the simulated is smaller. But we can see by the empirical se lines that those cases don't exist in our data.
mean(ibd_slopes_sim$overlap)

ggplot()+
  geom_histogram(data=as.data.frame(ibd_slopes_sim),aes(x=ibd_slope), bins=12)+
  geom_vline(aes(xintercept=c(slope_emp-se_emp, slope_emp, slope_emp+se_emp), color='empirical value', lty=(c('se','mean','se'))),lwd=1)+
#  labs(title=paste0('Distribution of IBD slope over simulated timesteps (empirical value mean +/- se in red)\n Simulated value within 1se of empirical: ',round(within_emp_se,2),'\n Empirical value within 1se of simulated: ',round(mean(ibd_slopes_sim$emp_in),2)))+
  labs(title=paste0('Distribution of IBD slope over simulated timesteps (empirical value mean +/- se in red)\nSimulated and empirical values within 1 s.e.: ',round(mean(ibd_slopes_sim$overlap),2)))+
  theme(legend.position="none")

```


```{r}
## all populations
ggplot(fst_summary_dists,aes(x=dist,y=scale_sim))+
  geom_point(size=1.1)+
  theme_bw()+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(title=paste0('Sim ',n_run),x='distance (km)',y='FST/(1-FST)')+
  facet_wrap(vars(both_pops))

ggplot(fst_summary_dists,aes(x=dist,y=scale_emp))+
  geom_point(size=1.1)+
  theme_bw()+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(title='Empirical',x='distance (km)',y='FST/(1-FST)')+
  facet_wrap(vars(both_pops))

```



## Analyses from D'Aloia et al 2020

```{r}
library(adegenet)
library(vcfR)
library(dartR)
library(snpStats)

treefile <- "full_pop_run/VCFs/A1/ts_9143221642690466364_t009600"
inds <- read_csv(paste0(treefile,".csv"),col_names=F,show_col_types=FALSE)
inds <- as.data.frame(t(inds))
inds <- separate_wider_delim(inds,cols=V1,delim=',',names=c('flags','x','y','zero','parents','array','dtype','pedID','pedp1','pedp2','age','subpop','sex','flags2')) %>%
  dplyr::select(x,y,pedID,pedp1,pedp2,age,sex)

inds <- mutate(inds,x = as.numeric(gsub("[^0-9.]","",x))) %>%
  mutate(y = as.numeric(gsub("[^0-9.]","",y))) %>%
  mutate(pedID = as.factor(gsub("[^0-9.]","",pedID))) %>%
  mutate(pedp1 = str_sub(gsub("\\D","",pedp1),start=2)) %>%
  mutate(pedp2 = str_sub(gsub("\\D","",pedp2),start=2)) %>%
  mutate(age = as.numeric(gsub("\\D","",age))) %>%
  mutate(sex = as.numeric(gsub("\\D","",sex))) %>%
  mutate(id=0:(nrow(inds)-1))

sites <- read_csv(paste0(treefile,"_sites.csv"),col_names=F)
sites <- as.data.frame(t(sites))
colnames(sites) = c('pedID','site_member')
sites <- mutate(sites,pedID=as.factor(pedID))

# make a column in inds so that ids exactly match the vcf
inds <- mutate(inds,gt_name=paste0("tsk_",id))
inds <- left_join(inds,sites,by="pedID")

sample_sites <- read_csv('../data/sgs_sites_SLiM.csv',show_col_types=FALSE)
sitenames <- data.frame(site_name = sample_sites$Site, site_member = as.factor(1:nrow(sample_sites)))
inds$site_member <- as.factor(inds$site_member)
inds <- left_join(inds,sitenames,by="site_member")

# create a factor of the sampling site of each individual in vcf
ind_sites <- as.factor(arrange(inds,id)$site_name)
ind_sites <- as.factor(substr(ind_sites,1,1))


simVCF <- read.vcfR(paste0(treefile,".vcf"),verbose=FALSE)
simGI <- vcfR2genind(simVCF)
simGI@pop <- ind_sites
simGL <- gi2gl(simGI,verbose=0)

#############################################################################
# Filter: LD and rare alleles
#############################################################################

# LD:
simGL@pop <- as.factor(rep('pop1',length(simGL@ind.names))) #remove site info temporarily
ld_report <- gl.report.ld.map(simGL,maf=0.02, plot.out=FALSE)
simGL <- gl.filter.ld(simGL,ld_report, threshold=0.8, verbose=3) # R^2>0.8 is what was used in the paper
simGL@pop <- ind_sites #restore site info

# rare alleles
simGL <- gl.filter.maf(simGL,threshold=0.02, plot.out=FALSE, verbose=3) # also removes monomorphic loci

#############################################################################
# Calculate pairwise fsts
#############################################################################
# do FST just to check if it's working. Answer: yes. I get exactly the same FST matrix here as I did when I analyzed the data the first time. So the right site is associated with each individual, etc.
#fsts <- gl.fst.pop(simGL,nboots=1, verbose=3)
```



```{r}
grp <- find.clusters(simGL, max.n.clust = 40, n.pca=1300, n.clust=7)
#grp <- find.clusters(simGI, max.n.clust = 40, n.pca=1300, n.clust=7)
table(pop(simGL),grp$grp) # this isn't working very well; doesn't look like there's any connection between an individual's site and what cluster it ends up in. Did I mess something up in the data-processing? Checked by running the FST matrix, and it looks exactly the same. So no problem there. 

dapc1 <- dapc(simGL, grp$grp, n.pca=200)

plotting_data <- cbind(dapc1$ind.coord,pop=simGL@pop)
ggplot(plotting_data,aes(x=LD1,y=LD2,color=as.factor(pop)))+
    geom_point()

dapc1
```

## Here's the empirical SNP data
(It's not in a format I can immediately use. VCF-ish, but without the metadata and some of the intro columns.)
```{r}
goby <- read.csv("goby_genotypes_SNP.txt", sep="\t", skip=1)

```


